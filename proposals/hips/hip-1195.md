# HIP-1195: Hiero hooks and an application to allowances

HIP: https://hips.hedera.com/hip/hip-1195

This HIP introduces **hooks**, programmable Hiero extension points that let users customize the behavior of their entities. The initial implementation focuses on **EVM hooks** and **account allowance hooks** as the first extension point.

## New APIs

#### HookExtensionPoint
```
enum HookExtensionPoint {
    ACCOUNT_ALLOWANCE_HOOK = 0
}
```

#### HookCreationDetails
```
// The details of a hook's creation.
type HookCreationDetails {
    // The extension point for the hook.
    HookExtensionPoint extensionPoint

    // The id to create the hook at.
    uint64 hookId

    // The hook implementation.
    // A hook programmed in EVM bytecode that may access state or interact with external contracts.
    LambdaEvmHook lambdaHook 

    // A key that that can be used to remove or replace the hook.
    Key adminKey
}
```

#### LambdaEvmHook
```
// Definition of a lambda EVM hook.
type LambdaEvmHook extends EvmHookSpec {
    // Initial storage updates for the lambda, if any.
    List<LambdaStorageUpdate> storageUpdates
}

// Shared specifications for an EVM hook. May be used for any extension point.
type EvmHookSpec {
    // The source of the EVM bytecode for the hook.
    ContractId contractId
}
```

#### LambdaStorageUpdate
```
// Specifies a key/value pair in the storage of a lambda, either by the explicit storage slot contents; or by a combination of a Solidity mapping's slot key and the key into that mapping.
type LambdaStorageUpdate {
    // oneof (mutually exclusive):

    // An explicit storage slot update.
    LambdaStorageSlot storageSlot  

    // An implicit storage slot update specified as a Solidity mapping entry.
    LambdaMappingEntry mappingEntry 
}

type LambdaStorageSlot {
    // 32-byte storage slot key
    bytes key

    // 32-byte storage slot value (empty to delete)
    bytes value
}

type LambdaMappingEntry {
    // Slot corresponding to Solidity mapping
    bytes mappingSlot

    // 32-byte key of mapping entry
    bytes key

    // 32-byte value of mapping entry (empty to delete)
    bytes value
}
```

#### HookCall and EvmHookCall
```
// Specifies a call to a hook from within a transaction where the hook owner is implied by the point of use.
type HookCall {
    // The id of the hook to call.
    uint64 hookId

    // Specification of how to call an EVM hook.
    EvmHookCall evmHookCall 
}

// Specifies details of a call to an EVM hook.
type EvmHookCall {
    // Call data to pass to the hook.
    bytes data

    // The gas limit to use.
    uint64 gasLimit
}
```

#### LambdaSStoreTransaction
```
// Adds or removes key/value pairs in the storage of a lambda.
type LambdaSStoreTransaction {
    // The id of the lambda whose storage is being updated.
    CreatedHookId hookId

    // The updates to the storage of the lambda.
    List<LambdaStorageUpdate> storageUpdates 
}
```

## Updated APIs

#### AccountCreateTransaction
- `addHook(HookCreationDetails)` - Add a hook to be created with the account
- `setHooks(List<HookCreationDetails>)` - Set hooks to be created with the account
- `List<HookCreationDetails> getHooks()` - Get the list of hooks to be created

#### AccountUpdateTransaction  
- `addHook(HookCreationDetails)` - Add a hook to be created for the account
- `setHooks(List<HookCreationDetails>)` - Set hooks to be created with the account
- `deleteHook(uint64)` - Mark a hook for deletion from the account
- `deleteHooks(List<uint64>)` - Mark hooks for deletion from the account
- `List<HookCreationDetails> getHooksToCreate()` - Get the list of hooks to be created
- `List<uint64> getHooksToDelete()` - Get the list of hook IDs to be deleted

#### ContractCreateTransaction
- `addHook(HookCreationDetails)` - Add a hook to be created with the contract
- `setHooks(List<HookCreationDetails>)` - Set hooks to be created with the contract 
- `List<HookCreationDetails> getHooks()` - Get the list of hooks to be created

#### ContractUpdateTransaction
- `addHook(HookCreationDetails)` - Add a hook to be created for the contract
- `setHooks(List<HookCreationDetails>)` - Set hooks to be created with the contract
- `deleteHook(uint64)` - Mark a hook for deletion from the contract
- `deleteHooks(List<uint64>)` - Mark hooks for deletion from the contract
- `List<HookCreationDetails> getHooksToCreate()` - Get the list of hooks to be created
- `List<uint64> getHooksToDelete()` - Get the list of hook IDs to be deleted

#### TransferTransaction

**HBAR Transfer Methods with Hooks:**

- `addHbarTransferWithPreTxHook(AccountId, amount, HookCall)` - Add HBAR transfer with pre-transaction hook
- `addHbarTransferWithPrePostTxHook(AccountId, amount, HookCall)` - Add HBAR transfer with pre/post-transaction hook

**NFT Transfer Methods with Hooks:**

- `addNftTransferWithPreTxSenderHook(NftId, sender, receiver, HookCall)` - Add NFT transfer with sender pre-transaction hook
- `addNftTransferWithPrePostTxSenderHook(NftId, sender, receiver, HookCall)` - Add NFT transfer with sender pre/post-transaction hook
- `addNftTransferWithPreTxReceiverHook(NftId, sender, receiver, HookCall)` - Add NFT transfer with receiver pre-transaction hook
- `addNftTransferWithPrePostTxReceiverHook(NftId, sender, receiver, HookCall)` - Add NFT transfer with receiver pre/post-transaction hook
- `addNftTransferWithSenderReceiverHooks(NftId, sender, receiver, senderHook, receiverHook)` - Add NFT transfer with both sender and receiver hooks

**Token Transfer Methods with Hooks:**

- `addTokenTransferWithPreTxHook(TokenId, AccountId, amount, HookCall)` - Add token transfer with pre-transaction hook
- `addTokenTransferWithPrePostTxHook(TokenId, AccountId, amount, HookCall)` - Add token transfer with pre/post-transaction hook

## Test Plan

### AccountCreateTransaction

1. **Given** an AccountCreateTransaction is configured with a lambda EVM hook and initial storage updates, **when** the transaction is executed, **then** the account is created with the lambda hook and storage is initialized correctly.

### AccountUpdateTransaction

2. **Given** an account exists without hooks, **when** an AccountUpdateTransaction adds a lambda EVM hook with initial storage, **then** the lambda hook is attached and storage slots are created.

3. **Given** an account exists with multiple hooks, **when** an AccountUpdateTransaction attempts to add a hook with a duplicate hook ID, **then** the transaction fails with an invalid hook ID error.

4. **Given** an account exists with hooks, **when** an AccountUpdateTransaction deletes specific hooks by ID with valid signatures, **then** the specified hooks are removed from the account.

### ContractCreateTransaction

5. **Given** a ContractCreateTransaction is configured with a lambda EVM hook and initial storage, **when** the transaction is executed, **then** the contract is created with the lambda hook and storage initialized.

### ContractUpdateTransaction

6. **Given** a contract exists without hooks, **when** a ContractUpdateTransaction adds hooks with valid signatures, **then** the hooks are successfully attached to the contract.

7. **Given** a contract exists with hooks, **when** a ContractUpdateTransaction deletes hooks by ID with valid signatures, **then** the specified hooks are removed from the contract.

### AccountInfoQuery

8. **Given** an account has lambda hooks with storage, **when** an AccountInfoQuery is executed, **then** the response includes the correct number of hooks, first hook ID, and lambda storage slot count.

### ContractInfoQuery

9. **Given** a contract has lambda hooks with storage, **when** a ContractInfoQuery is executed, **then** the response includes the correct number of hooks, first hook ID, and lambda storage slot count.

### LambdaSStoreTransaction

10. **Given** a lambda hook exists with storage, **when** a LambdaSStoreTransaction updates storage slots with valid signatures, **then** the storage is updated successfully.

11. **Given** a lambda hook exists, **when** a LambdaSStoreTransaction attempts to update storage without proper signatures, **then** the transaction fails with an unauthorized error.

### TransferTransaction

12. **Given** an account has a pre-transaction allowance hook configured, **when** a TransferTransaction attempts to transfer HBAR from that account, **then** the hook is called before the transfer and approves the transaction.

13. **Given** an account has a pre-transaction allowance hook that validates transfer limits, **when** a TransferTransaction exceeds the allowed amount, **then** the hook rejects the transfer and the transaction fails.

14. **Given** an account has a pre/post-transaction allowance hook configured, **when** a successful HBAR transfer occurs, **then** the hook is called both before and after the transfer execution.

15. **Given** an account has an allowance hook for token transfers, **when** a TransferTransaction includes token transfers from that account, **then** the hook validates the token allowance and approves valid transfers.

16. **Given** an account has an NFT allowance hook configured, **when** a TransferTransaction attempts to transfer an NFT from that account, **then** the hook validates the NFT allowance and processes the transfer accordingly.

17. **Given** multiple accounts in a transfer have different allowance hooks, **when** a TransferTransaction involves all accounts, **then** each account's respective hooks are called and must all approve for the transaction to succeed.

18. **Given** an account has an allowance hook that tracks daily transfer limits, **when** multiple TransferTransactions are executed within the same day, **then** the hook maintains state and enforces cumulative limits correctly.

19. **Given** a sender account has an allowance hook and receiver account has a different allowance hook, **when** a TransferTransaction occurs between them, **then** both sender and receiver hooks are executed in the correct order.

20. **Given** a TransferTransaction uses the combined addHbarTransferWithPreTxHook method, **when** the transaction is executed, **then** both the transfer and hook are applied correctly in a single operation.

21. **Given** a TransferTransaction uses the combined addNftTransferWithSenderReceiverHooks method, **when** the transaction is executed, **then** the NFT transfer occurs with both sender and receiver hooks properly configured.

22. **Given** a TransferTransaction uses addTokenTransferWithPrePostTxHook for a fungible token, **when** the transaction is executed, **then** the token transfer occurs with the hook called before and after the transaction.

23. **Given** multiple transfer methods with hooks are combined in a single TransferTransaction, **when** the transaction is executed, **then** all transfers and their respective hooks are processed correctly without conflicts.

## Examples

### Creating an Account with a Lambda EVM Hook

```javascript
import {
  LambdaEvmHook,
  LambdaStorageUpdate,
  LambdaStorageSlot
} from "@hashgraph/sdk";

// Step 1: Create initial storage updates
const storageUpdates = [
  new LambdaStorageUpdate().setStorageSlot(
    new LambdaStorageSlot()
      .setKey(new Uint8Array(32).fill(1)) 
      .setValue(new Uint8Array(32).fill(100))
  )
];

// Step 2: Create lambda hook with storage
const lambdaHookDetails = new HookCreationDetails()
  .setExtensionPoint(HookExtensionPoint.ACCOUNT_ALLOWANCE_HOOK)
  .setHookId(1002)
  .setLambdaHook(new LambdaEvmHook()
    .setContractId(ContractId.fromString("0.0.67890"))
    .setStorageUpdates(storageUpdates))
  .setAdminKey(adminKey.publicKey);

// Step 3: Create account with lambda hook
const accountCreateTx = new AccountCreateTransaction()
  .setKey(accountKey.publicKey)
  .addHook(lambdaHookDetails)
  .freezeWith(client)
  .sign(accountKey);

const response = await accountCreateTx.execute(client);
const accountId = (await response.getReceipt(client)).accountId;
```

### Adding Hooks to an Existing Account

```javascript
import { AccountUpdateTransaction } from "@hashgraph/sdk";

const accountUpdateTx = new AccountUpdateTransaction()
  .setAccountId(existingAccountId)
  .addHook(hookDetails1)
  .addHook(hookDetails2)
  .freezeWith(client)
  .sign(accountKey)
  .sign(adminKey);

await accountUpdateTx.execute(client);
```

### Updating Lambda Hook Storage

```javascript
import { LambdaSStoreTransaction } from "@hashgraph/sdk";

const storageUpdate = new LambdaStorageUpdate()
  .setStorageSlot(new LambdaStorageSlot()
    .setKey(new Uint8Array(32).fill(1))
    .setValue(new Uint8Array(32).fill(200)));

const lambdaStoreTx = new LambdaSStoreTransaction()
  .setHookId(1002)
  .addStorageUpdate(storageUpdate)
  .freezeWith(client)
  .sign(adminKey);

await lambdaStoreTx.execute(client);
```

### Transferring HBAR, NFTs or FTs
```javascript

// Create different hooks for different transfer types
const hbarHook = new HookCall()
  .setHookId(1001)
  .setEvmHookCall(new EvmHookCall()
    .setData(new Uint8Array([0x01, 0x02])) 
    .setGasLimit(50000));

const nftSenderHook = new HookCall()
  .setHookId(1002)
  .setEvmHookCall(new EvmHookCall()
    .setData(new Uint8Array([0x03, 0x04]))
    .setGasLimit(60000));

const nftReceiverHook = new HookCall()
  .setHookId(1003)
  .setEvmHookCall(new EvmHookCall()
    .setData(new Uint8Array([0x05, 0x06]))
    .setGasLimit(40000));

const fungibleTokenHook = new HookCall()
  .setHookId(1004)
  .setEvmHookCall(new EvmHookCall()
    .setData(new Uint8Array([0x07, 0x08])) 
    .setGasLimit(70000));

const nftId = new NftId(TokenId.fromString("0.0.12345"), 1);
const tokenId = TokenId.fromString("0.0.54321");

const tx = new TransferTransaction()
  // HBAR transfers with hook
  .addHbarTransferWithPreTxHook(senderAccountId, Hbar.from(-100), hbarHook)
  .addHbarTransfer(receiverAccountId, Hbar.from(100))
  // NFT transfer with both sender and receiver hooks
  .addNftTransferWithSenderReceiverHooks(nftId, senderAccountId, receiverAccountId, nftSenderHook, nftReceiverHook)
  // Fungible token transfers with hook
  .addTokenTransferWithPreTxHook(tokenId, senderAccountId, -1000, fungibleTokenHook)
  .addTokenTransfer(tokenId, receiverAccountId, 1000)
  .freezeWith(client)
  .sign(senderKey);

const result = await tx.execute(client);
console.log(`Transaction executed with ID: ${result.transactionId}`);
```
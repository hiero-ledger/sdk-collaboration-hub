# Fee Estimation Query API

This design introduces a **fee estimation query** that allows users, SDKs, and tools to query expected transaction fees without submitting transactions to the network. The feature is backed by a new Mirror gRPC `NetworkService.getFeeEstimate` endpoint that accepts a `FeeEstimateQuery` with an `EstimateMode` and returns a structured `FeeEstimateResponse` containing network, node, and service fee components.

## Summary

The fee estimation API enables users to predict transaction costs before submission, supporting two estimation modes:

- **STATE mode** (default): Estimates based on intrinsic properties plus the latest known state (e.g., account existence, token associations)
- **INTRINSIC mode**: Estimates based solely on transaction's inherent properties (size, signatures, keys), ignoring state-dependent factors

This feature improves user experience by providing cost transparency and enabling better transaction planning. The API follows existing SDK query patterns with builder-style fluent interfaces.

## New APIs

#### FeeEstimateMode

```
enum FeeEstimateMode {
    STATE = 0;      // Default: uses latest known state
    INTRINSIC = 1;  // Ignores state-dependent factors
}
```

#### FeeEstimateResponse

```
// The response containing the estimated transaction fees.
type FeeEstimateResponse {
    // The mode that was used to calculate the fees.
    FeeEstimateMode mode

    // The network fee component which covers the cost of gossip, consensus,
    // signature verifications, fee payment, and storage.
    NetworkFee network

    // The node fee component which is to be paid to the node that submitted the
    // transaction to the network.
    FeeEstimate node

    // The service fee component which covers execution costs, state saved in the
    // Merkle tree, and additional costs to the blockchain storage.
    FeeEstimate service

    // An array of strings for any caveats (e.g., ["Fallback to worst-case due to missing state"]).
    List<string> notes

    // The sum of the network, node, and service subtotals in tinycents.
    uint64 total
}
```

#### FeeEstimate

```
// The fee estimate for a component. Includes the base fee and any extras.
type FeeEstimate {
    // The base fee price, in tinycents.
    uint64 base

    // The extra fees that apply for this fee component.
    List<FeeExtra> extras
}
```

#### FeeExtra

```
// The extra fee charged for the transaction.
type FeeExtra {
    // The unique name of this extra fee as defined in the fee schedule.
    string name

    // The count of this "extra" that is included for free.
    uint32 included

    // The actual count of items received.
    uint32 count

    // The charged count of items as calculated by max(0, count - included).
    uint32 charged

    // The fee price per unit in tinycents.
    uint64 feePerUnit

    // The subtotal in tinycents for this extra fee. Calculated by multiplying the
    // charged count by the feePerUnit.
    uint64 subtotal
}
```

#### NetworkFee

```
// The network fee component which covers the cost of gossip, consensus,
// signature verifications, fee payment, and storage.
type NetworkFee {
    // Multiplied by the node fee to determine the total network fee.
    uint32 multiplier

    // The subtotal in tinycents for the network fee component which is calculated by
    // multiplying the node subtotal by the network multiplier.
    uint64 subtotal
}
```

### Queries

#### FeeEstimateQuery

```
// Request object for users, SDKs, and tools to query expected fees without
// submitting transactions to the network.
type FeeEstimateQuery extends Query<FeeEstimateResponse> {
    // The mode of fee estimation. Defaults to STATE if omitted.
    FeeEstimateMode mode

    // The raw HAPI transaction that should be estimated.
    Transaction transaction
}
```

**Methods:**

- `setMode(FeeEstimateMode mode)` - Set the estimation mode (optional, defaults to STATE)
- `getMode()` - Get the current estimation mode
- `setTransaction(Transaction transaction)` - Set the transaction to estimate (required)
- `getTransaction()` - Get the current transaction
- `execute(Client client)` - Execute the fee estimation query

## Updated APIs

### Response Codes

No new consensus node response codes. Mirror gRPC may return standard gRPC status codes:

- `UNAVAILABLE` - Mirror service temporarily unavailable
- `DEADLINE_EXCEEDED` - Request timeout
- `INVALID_ARGUMENT` - Malformed transaction or request

#### Transaction Retry

- Retry on transient transport errors (`UNAVAILABLE`, `DEADLINE_EXCEEDED`) per existing query retry policy
- Do not retry on `INVALID_ARGUMENT` (malformed transaction)

## Test Plan

### Basic Functionality Tests

1. **Given** a simple `TransferTransaction` is created, **when** a `FeeEstimateQuery` is executed with `STATE` mode, **then** the SDK automatically freezes the transaction if needed and returns valid fee components (network, node, service) with the total matching the sum of all components.

2. **Given** a simple `TransferTransaction` is created, **when** a `FeeEstimateQuery` is executed with `INTRINSIC` mode, **then** the response contains valid fee components and the total is calculated without state-dependent factors.

3. **Given** a `FeeEstimateQuery` is created without setting a mode, **when** the query is executed, **then** the response contains `mode: FeeEstimateMode.STATE` indicating the Mirror node used STATE mode as the default.

4. **Given** a `FeeEstimateQuery` is created without setting a transaction, **when** the query is executed, **then** it throws an appropriate error indicating the transaction is required.

### Transaction Type Coverage Tests

5. **Given** a `TokenCreateTransaction` is created, **when** a fee estimate is requested, **then** the response includes appropriate service fees for token creation and network fees for the transaction size.

6. **Given** a `TokenMintTransaction` with multiple token IDs, **when** a fee estimate is requested, **then** the response includes extra fees for each additional token minted beyond the included amount.

7. **Given** a `TopicCreateTransaction` is created, **when** a fee estimate is requested, **then** the response includes appropriate fees for consensus service operations.

8. **Given** a `ContractCreateTransaction` is created, **when** a fee estimate is requested, **then** the response includes appropriate fees for contract deployment and storage.

9. **Given** a `FileCreateTransaction` is created, **when** a fee estimate is requested, **then** the response includes appropriate fees for file storage based on size.

### Fee Component Validation Tests

10. **Given** any valid transaction, **when** a fee estimate is requested, **then** the `network.subtotal` equals `node.subtotal * network.multiplier`.

11. **Given** any valid transaction, **when** a fee estimate is requested, **then** the `total` equals the sum of `network.subtotal + node.subtotal + service.subtotal`.

### Error Handling Tests

12. **Given** a `FeeEstimateQuery` with a malformed transaction, **when** the query is executed, **then** it returns an `INVALID_ARGUMENT` error and does not retry.

13. **Given** a `FeeEstimateQuery` is executed when the Mirror service is unavailable, **when** the query is executed, **then** it retries according to the existing query retry policy for `UNAVAILABLE` errors.

14. **Given** a `FeeEstimateQuery` times out, **when** the query is executed, **then** it retries according to the existing query retry policy for `DEADLINE_EXCEEDED` errors.

### Integration Tests

15. **Given** a fee estimate is obtained for a transaction, **when** the same transaction is actually submitted to the network, **then** the actual fees should be within a reasonable range of the estimated fees.

**Note:** A reasonable range should be discussed in this PR before merging it.

### Client Compatibility Tests - JS ONLY

16. **Given** a `FeeEstimateQuery` is executed with different client types (NodeClient, WebClient, NativeClient), **when** the same transaction is estimated, **then** all clients return consistent results.

### FileAppendTransaction Chunking Tests

17. **Given** a `FileAppendTransaction` with content smaller than the chunk size, **when** a fee estimate is requested, **then** the response includes fees for a single transaction with appropriate file storage costs.

18. **Given** a `FileAppendTransaction` with content larger than the chunk size, **when** a fee estimate is requested, **then** the response includes fees for multiple transactions (chunks) with appropriate file storage costs for each chunk.

19. **Given** a `FileAppendTransaction` with content exactly at the chunk size boundary, **when** a fee estimate is requested, **then** the response includes fees for exactly two transactions (one full chunk + one partial chunk).

### FileAppendTransaction Integration Tests

20. **Given** a fee estimate is obtained for a `FileAppendTransaction` with multiple chunks, **when** the same transaction is actually submitted to the network, **then** the actual fees should match the estimated fees for the correct number of chunks.

## Examples

### Estimating Fees for a Transfer Transaction

```javascript
import {
  FeeEstimateQuery,
  FeeEstimateMode,
  TransferTransaction,
  Hbar,
} from "@hashgraph/sdk";

// Step 1: Create and freeze a transfer transaction
const tx = await new TransferTransaction()
  .addHbarTransfer(aliceId, new Hbar(-1))
  .addHbarTransfer(bobId, new Hbar(1))
  .freezeWith(client);

// Step 2: Estimate fees with STATE mode (default)
const estimate = await new FeeEstimateQuery()
  .setMode(FeeEstimateMode.STATE)
  .setTransaction(tx)
  .execute(client);

// Step 3: Display fee breakdown
console.log({
  mode: estimate.mode,
  network: estimate.network.subtotal.toString(),
  node: (
    estimate.node.base +
    estimate.node.extras.reduce((s, e) => s + e.subtotal, 0)
  ).toString(),
  service: (
    estimate.service.base +
    estimate.service.extras.reduce((s, e) => s + e.subtotal, 0)
  ).toString(),
  total: estimate.total.toString(),
  notes: estimate.notes,
});
```

### Estimating Fees with INTRINSIC Mode

```javascript
import { FeeEstimateQuery, FeeEstimateMode } from "@hashgraph/sdk";

// Step 1: Create transaction (no need to sign for intrinsic estimate)
const tx = await new TransferTransaction()
  .addHbarTransfer(aliceId, new Hbar(-100))
  .addHbarTransfer(bobId, new Hbar(100))
  .freezeWith(client);

// Step 2: Estimate with INTRINSIC mode
const intrinsicEstimate = await new FeeEstimateQuery()
  .setMode(FeeEstimateMode.INTRINSIC)
  .setTransaction(tx)
  .execute(client);

// Step 3: Compare with STATE mode estimate
const stateEstimate = await new FeeEstimateQuery()
  .setMode(FeeEstimateMode.STATE)
  .setTransaction(tx)
  .execute(client);

console.log({
  intrinsic: intrinsicEstimate.total.toString(),
  state: stateEstimate.total.toString(),
  difference: (stateEstimate.total - intrinsicEstimate.total).toString(),
});
```

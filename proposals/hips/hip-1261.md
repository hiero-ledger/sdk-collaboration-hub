# Fee Estimation Query API

This design introduces a **fee estimation query** that allows users, SDKs, and tools to query expected transaction fees without submitting transactions to the network. The feature is backed by a new Mirror gRPC `NetworkService.getFeeEstimate` endpoint that accepts a `FeeEstimateQuery` with an `EstimateMode` and returns a structured `FeeEstimateResponse` containing network, node, and service fee components.

## Summary

The fee estimation API enables users to predict transaction costs before submission, supporting two estimation modes:

- **STATE mode** (default): Estimates based on intrinsic properties plus the latest known state (e.g., account existence, token associations)
- **INTRINSIC mode**: Estimates based solely on transaction's inherent properties (size, signatures, keys), ignoring state-dependent factors

This feature improves user experience by providing cost transparency and enabling better transaction planning. The API follows existing SDK query patterns with builder-style fluent interfaces.

## New APIs

#### FeeEstimateMode

```
enum FeeEstimateMode {
    STATE = 0;      // Default: uses latest known state
    INTRINSIC = 1;  // Ignores state-dependent factors
}
```

#### FeeEstimateResponse

```
// The response containing the estimated transaction fees.
type FeeEstimateResponse {
    // The mode that was used to calculate the fees.
    FeeEstimateMode mode

    // The network fee component which covers the cost of gossip, consensus,
    // signature verifications, fee payment, and storage.
    NetworkFee network

    // The node fee component which is to be paid to the node that submitted the
    // transaction to the network.
    FeeEstimate node

    // The service fee component which covers execution costs, state saved in the
    // Merkle tree, and additional costs to the blockchain storage.
    FeeEstimate service

    // An array of strings for any caveats (e.g., ["Fallback to worst-case due to missing state"]).
    List<string> notes

    // The sum of the network, node, and service subtotals in tinycents.
    uint64 total
}
```

#### FeeEstimate

```
// The fee estimate for a component. Includes the base fee and any extras.
type FeeEstimate {
    // The base fee price, in tinycents.
    uint64 base

    // The extra fees that apply for this fee component.
    List<FeeExtra> extras
}
```

#### FeeExtra

```
// The extra fee charged for the transaction.
type FeeExtra {
    // The unique name of this extra fee as defined in the fee schedule.
    string name

    // The count of this "extra" that is included for free.
    uint32 included

    // The actual count of items received.
    uint32 count

    // The charged count of items as calculated by max(0, count - included).
    uint32 charged

    // The fee price per unit in tinycents.
    uint64 feePerUnit

    // The subtotal in tinycents for this extra fee. Calculated by multiplying the
    // charged count by the feePerUnit.
    uint64 subtotal
}
```

#### NetworkFee

```
// The network fee component which covers the cost of gossip, consensus,
// signature verifications, fee payment, and storage.
type NetworkFee {
    // Multiplied by the node fee to determine the total network fee.
    uint32 multiplier

    // The subtotal in tinycents for the network fee component which is calculated by
    // multiplying the node subtotal by the network multiplier.
    uint64 subtotal
}
```

### Queries

#### FeeEstimateQuery

```
// Request object for users, SDKs, and tools to query expected fees without
// submitting transactions to the network.
type FeeEstimateQuery extends Query<FeeEstimateResponse> {
    // The mode of fee estimation. Defaults to STATE if omitted.
    FeeEstimateMode mode

    // The raw HAPI transaction that should be estimated.
    Transaction transaction
}
```

**Methods:**

- `setMode(FeeEstimateMode mode)` - Set the estimation mode (optional, defaults to STATE)
- `getMode()` - Get the current estimation mode
- `setTransaction(Transaction transaction)` - Set the transaction to estimate (required)
- `getTransaction()` - Get the current transaction
- `execute(Client client)` - Execute the fee estimation query

## Updated APIs

### Response Codes

No new consensus node response codes. Mirror gRPC may return standard gRPC status codes:

- `UNAVAILABLE` - Mirror service temporarily unavailable
- `DEADLINE_EXCEEDED` - Request timeout
- `INVALID_ARGUMENT` - Malformed transaction or request

#### Transaction Retry

- Retry on transient transport errors (`UNAVAILABLE`, `DEADLINE_EXCEEDED`) per existing query retry policy
- Do not retry on `INVALID_ARGUMENT` (malformed transaction)

## Test Plan

TBD

## Examples

### Estimating Fees for a Transfer Transaction

```javascript
import {
  FeeEstimateQuery,
  FeeEstimateMode,
  TransferTransaction,
  Hbar,
} from "@hashgraph/sdk";

// Step 1: Create and freeze a transfer transaction
const tx = await new TransferTransaction()
  .addHbarTransfer(aliceId, new Hbar(-1))
  .addHbarTransfer(bobId, new Hbar(1))
  .freezeWith(client);

// Step 2: Estimate fees with STATE mode (default)
const estimate = await new FeeEstimateQuery()
  .setMode(FeeEstimateMode.STATE)
  .setTransaction(tx)
  .execute(client);

// Step 3: Display fee breakdown
console.log({
  mode: estimate.mode,
  network: estimate.network.subtotal.toString(),
  node: (
    estimate.node.base +
    estimate.node.extras.reduce((s, e) => s + e.subtotal, 0)
  ).toString(),
  service: (
    estimate.service.base +
    estimate.service.extras.reduce((s, e) => s + e.subtotal, 0)
  ).toString(),
  total: estimate.total.toString(),
  notes: estimate.notes,
});
```

### Estimating Fees with INTRINSIC Mode

```javascript
import { FeeEstimateQuery, FeeEstimateMode } from "@hashgraph/sdk";

// Step 1: Create transaction (no need to sign for intrinsic estimate)
const tx = await new TransferTransaction()
  .addHbarTransfer(aliceId, new Hbar(-100))
  .addHbarTransfer(bobId, new Hbar(100))
  .freezeWith(client);

// Step 2: Estimate with INTRINSIC mode
const intrinsicEstimate = await new FeeEstimateQuery()
  .setMode(FeeEstimateMode.INTRINSIC)
  .setTransaction(tx)
  .execute(client);

// Step 3: Compare with STATE mode estimate
const stateEstimate = await new FeeEstimateQuery()
  .setMode(FeeEstimateMode.STATE)
  .setTransaction(tx)
  .execute(client);

console.log({
  intrinsic: intrinsicEstimate.total.toString(),
  state: stateEstimate.total.toString(),
  difference: (stateEstimate.total - intrinsicEstimate.total).toString(),
});
```

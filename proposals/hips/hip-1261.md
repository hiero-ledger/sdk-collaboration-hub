# Fee Estimation Query API

This design introduces a **fee estimation query** that allows users, SDKs, and tools to query expected transaction fees without submitting transactions to the network. The feature is backed by a new Mirror gRPC `NetworkService.getFeeEstimate` endpoint that accepts a `FeeEstimateQuery` with an `EstimateMode` and returns a structured `FeeEstimateResponse` containing network, node, and service fee components.

## Summary

The fee estimation API enables users to predict transaction costs before submission, supporting two estimation modes:

- **STATE mode** (default): Estimate using the transaction plus the mirror node’s latest known state (e.g., whether an alias already maps to an account, required token associations exist, token types have custom fees, hooks/allowances apply). Produces the most realistic “what the network will charge” preview.

- **INTRINSIC mode**: Estimate from the payload alone (bytes, signatures, declared keys, gas), ignoring any state-dependent costs (e.g., account auto-creation, auto-associations, custom fees, hook invocations). Deterministic, fast, and always available—typically a lower-bound compared to STATE when hidden state work would add costs.

This feature improves user experience by providing cost transparency and enabling better transaction planning. The API follows existing SDK query patterns with builder-style fluent interfaces. Transactions are automatically frozen if not already frozen when the query is executed.

## New APIs

#### FeeEstimateMode

```
enum FeeEstimateMode {
    STATE       // Default: uses latest known state
    INTRINSIC   // Ignores state-dependent factors
}
```

#### FeeExtra

```
// The extra fee charged for the transaction.
FeeExtra {
    // The unique name of this extra fee as defined in the fee schedule.
    @immutable name: string

    // The count of this "extra" that is included for free.
    @immutable included: uint32

    // The actual count of items received.
    @immutable count: uint32

    // The charged count of items as calculated by max(0, count - included).
    @immutable charged: uint32

    // The fee price per unit in tinycents.
    @immutable feePerUnit: uint64

    // The subtotal in tinycents for this extra fee. Calculated by multiplying the
    // charged count by the feePerUnit.
    @immutable subtotal: uint64
}
```

#### FeeEstimate

```
// The fee estimate for a component. Includes the base fee and any extras.
FeeEstimate {
    // The base fee price, in tinycents.
    @immutable base: uint64

    // The extra fees that apply for this fee component.
    @immutable extras: list<FeeExtra>
}
```

#### NetworkFee

```
// The network fee component which covers the cost of gossip, consensus,
// signature verifications, fee payment, and storage.
NetworkFee {
    // Multiplied by the node fee to determine the total network fee.
    @immutable multiplier: uint32

    // The subtotal in tinycents for the network fee component which is calculated by
    // multiplying the node subtotal by the network multiplier.
    @immutable subtotal: uint64
}
```

#### FeeEstimateResponse

```
// The response containing the estimated transaction fees.
FeeEstimateResponse {
    // The mode that was used to calculate the fees.
    @immutable mode: FeeEstimateMode

    // The network fee component which covers the cost of gossip, consensus,
    // signature verifications, fee payment, and storage.
    @immutable networkFee: NetworkFee

    // The node fee component which is to be paid to the node that submitted the
    // transaction to the network.
    @immutable nodeFee: FeeEstimate

    // The service fee component which covers execution costs, state saved in the
    // Merkle tree, and additional costs to the blockchain storage.
    @immutable serviceFee: FeeEstimate

    // An array of strings for any caveats (e.g., ["Fallback to worst-case due to missing state"]).
    @immutable notes: list<string>

    // The sum of the network, node, and service subtotals in tinycents.
    @immutable total: uint64
}
```

### Queries

#### FeeEstimateQuery

```
// Request object for users, SDKs, and tools to query expected fees without
// submitting transactions to the network.
FeeEstimateQuery extends Query<FeeEstimateResponse> {
    // The mode of fee estimation. Defaults to STATE if omitted.
    @optional @default(STATE) mode: FeeEstimateMode

    // The raw HAPI transaction that should be estimated.
    transaction: Transaction

    // Set the estimation mode (optional, defaults to STATE).
    FeeEstimateQuery setMode(mode: FeeEstimateMode)

    // Get the current estimation mode.
    @optional FeeEstimateMode getMode()

    // Set the transaction to estimate (required).
    FeeEstimateQuery setTransaction(transaction: Transaction)

    // Get the current transaction.
    @optional Transaction getTransaction()
}
```

**Note:** The transaction will be automatically frozen if it is not already frozen when `execute()` is called.

#### Retry Policy

- Retry on transient transport errors (`UNAVAILABLE`, `DEADLINE_EXCEEDED`) per existing query retry policy
- Do not retry on `INVALID_ARGUMENT` (malformed transaction)

### Chunk Transaction

For transactions that are internally chunked by the SDK into multiple transactions (e.g `FileAppendTransaction` and `TopicMessageQuery`), the `FeeEstimateQuery` MUST aggregate all per‑chunk fees into a single `FeeEstimateResponse`.

- Examples: `FileAppendTransaction`, `TopicMessageSubmitTransaction`.
- Behavior:
  - The estimator computes fees for each chunk as if it were a separate transaction (including network, node, and service components).
  - The `FeeEstimateResponse` returned to the caller is a single aggregate:
    - `node.subtotal` equals the sum of all node subtotals across chunks.
    - `service.subtotal` equals the sum of all service subtotals across chunks.
    - `network.subtotal` is computed from the aggregated node subtotal and `network.multiplier`.
    - `total` equals `network.subtotal + node.subtotal + service.subtotal`.

## Test Plan

### Basic Functionality Tests

1. **Given** a simple `TransferTransaction` is created, **when** a `FeeEstimateQuery` is executed with `STATE` mode, **then** the SDK automatically freezes the transaction if needed and returns valid fee components (network, node, service) with the total matching the sum of all components.

2. **Given** a simple `TransferTransaction` is created, **when** a `FeeEstimateQuery` is executed with `INTRINSIC` mode, **then** the response contains valid fee components and the total is calculated without state-dependent factors.

3. **Given** a `FeeEstimateQuery` is created without setting a mode, **when** the query is executed, **then** the response contains `mode: FeeEstimateMode.STATE` indicating the Mirror node used STATE mode as the default.

4. **Given** a `FeeEstimateQuery` is created without setting a transaction, **when** the query is executed, **then** it throws an appropriate error indicating the transaction is required.

### Transaction Type Coverage Tests

5. **Given** a `TokenCreateTransaction` is created, **when** a fee estimate is requested, **then** the response includes appropriate service fees for token creation and network fees for the transaction size.

6. **Given** a `TokenMintTransaction` with multiple token IDs, **when** a fee estimate is requested, **then** the response includes extra fees for each additional token minted beyond the included amount.

7. **Given** a `TopicCreateTransaction` is created, **when** a fee estimate is requested, **then** the response includes appropriate fees for consensus service operations.

8. **Given** a `ContractCreateTransaction` is created, **when** a fee estimate is requested, **then** the response includes appropriate fees for contract deployment and storage.

9. **Given** a `FileCreateTransaction` is created, **when** a fee estimate is requested, **then** the response includes appropriate fees for file storage based on size.

### Fee Component Validation Tests

10. **Given** any valid transaction, **when** a fee estimate is requested, **then** the `network.subtotal` equals `node.subtotal * network.multiplier`.

11. **Given** any valid transaction, **when** a fee estimate is requested, **then** the `total` equals the sum of `network.subtotal + node.subtotal + service.subtotal`.

### Error Handling Tests

12. **Given** a `FeeEstimateQuery` with a malformed transaction, **when** the query is executed, **then** it returns an `INVALID_ARGUMENT` error and does not retry.

13. **Given** a `FeeEstimateQuery` is executed when the Mirror service is unavailable, **when** the query is executed, **then** it retries according to the existing query retry policy for `UNAVAILABLE` errors.

14. **Given** a `FeeEstimateQuery` times out, **when** the query is executed, **then** it retries according to the existing query retry policy for `DEADLINE_EXCEEDED` errors.

### Integration Tests

15. **Given** a fee estimate is obtained for a transaction, **when** the same transaction is actually submitted to the network, **then** the actual fees should be within a reasonable range of the estimated fees.

**Note:** A reasonable range should be discussed in this PR before merging it.

### Client Compatibility Tests - JS ONLY

16. **Given** a `FeeEstimateQuery` is executed with different client types (NodeClient, WebClient, NativeClient), **when** the same transaction is estimated, **then** all clients return consistent results.

### FileAppendTransaction Chunking Tests

17. Given a fee estimate is obtained for a `FileAppendTransaction` with multiple chunks, when the same transaction is actually submitted to the network, then the sum of actual fees across all submitted chunks should match the single aggregated estimate within an agreed tolerance.

## TopicMessageSubmitTransaction Chunking Tests

18. Given a `TopicMessageSubmitTransaction` payload smaller than the chunk size, when a fee estimate is requested, then the response includes fees aggregated for a single chunk.

19. Given a `TopicMessageSubmitTransaction` payload larger than the chunk size, when a fee estimate is requested, then the response aggregates fees for all chunks into a single estimate.

## Examples

### Estimating Fees for a Transfer Transaction

```javascript
import {
  FeeEstimateQuery,
  FeeEstimateMode,
  TransferTransaction,
  Hbar,
} from "@hashgraph/sdk";

// Step 1: Create and freeze a transfer transaction
const tx = await new TransferTransaction()
  .addHbarTransfer(aliceId, new Hbar(-1))
  .addHbarTransfer(bobId, new Hbar(1))
  .freezeWith(client);

// Step 2: Estimate fees with STATE mode (default)
const estimate = await new FeeEstimateQuery()
  .setMode(FeeEstimateMode.STATE)
  .setTransaction(tx)
  .execute(client);

// Step 3: Display fee breakdown
console.log({
  mode: estimate.mode,
  network: estimate.network.subtotal.toString(),
  node: (
    estimate.node.base +
    estimate.node.extras.reduce((s, e) => s + e.subtotal, 0)
  ).toString(),
  service: (
    estimate.service.base +
    estimate.service.extras.reduce((s, e) => s + e.subtotal, 0)
  ).toString(),
  total: estimate.total.toString(),
  notes: estimate.notes,
});
```

### Estimating Fees with INTRINSIC Mode

```javascript
import { FeeEstimateQuery, FeeEstimateMode } from "@hashgraph/sdk";

// Step 1: Create transaction (no need to sign for intrinsic estimate)
const tx = await new TransferTransaction()
  .addHbarTransfer(aliceId, new Hbar(-100))
  .addHbarTransfer(bobId, new Hbar(100))
  .freezeWith(client);

// Step 2: Estimate with INTRINSIC mode
const intrinsicEstimate = await new FeeEstimateQuery()
  .setMode(FeeEstimateMode.INTRINSIC)
  .setTransaction(tx)
  .execute(client);

// Step 3: Compare with STATE mode estimate
const stateEstimate = await new FeeEstimateQuery()
  .setMode(FeeEstimateMode.STATE)
  .setTransaction(tx)
  .execute(client);

console.log({
  intrinsic: intrinsicEstimate.total.toString(),
  state: stateEstimate.total.toString(),
  difference: (stateEstimate.total - intrinsicEstimate.total).toString(),
});
```

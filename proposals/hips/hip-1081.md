# HIP-1081: Block Node SDK Integration

## Summary

HIP-1081 introduces Block Nodes as a decentralized data layer for the Hiero network. Block Nodes receive block streams from Consensus Nodes, verify block integrity, store the blockchain, and distribute blocks to downstream clients such as Mirror Nodes, dApps, and other Block Nodes.

This design document defines the SDK APIs required for applications to interact with Block Nodes. The SDK enables developers to:
- Subscribe to real-time and historical block streams
- Query Block Node status and capabilities
- Retrieve specific blocks by number
- Request state snapshots
- Obtain cryptographic proofs for blocks and state data

Block Node connectivity is integrated into the existing `Client` class, following the established pattern where the `Client` manages connections to multiple network components (Consensus Nodes, Mirror Nodes, and now Block Nodes). This provides a consistent, unified experience for SDK users.

**HIP:** https://hips.hedera.com/hip/hip-1081

**Related HIPs:**
- [HIP-1056: Block Streams](https://hips.hedera.com/hip/hip-1056)
- [HIP-1137: Block Node Discoverability](https://github.com/hiero-ledger/hiero-improvement-proposals/pull/1137)
- [HIP-1183: The hinTS threshold signature scheme](https://github.com/hiero-ledger/hiero-improvement-proposals/pull/1200)

**Date Submitted:** 2025-01-07

---

## New APIs

### Enumerations

#### SubscribeStreamResponseCode

Response codes returned when subscribing to a block stream.

```
enum SubscribeStreamResponseCode {
    UNKNOWN
    SUCCESS
    INVALID_REQUEST
    ERROR
    INVALID_START_BLOCK_NUMBER
    INVALID_END_BLOCK_NUMBER
    NOT_AVAILABLE
}
```

#### BlockAccessResponseCode

Response codes returned when accessing a single block.

```
enum BlockAccessResponseCode {
    UNKNOWN
    SUCCESS
    INVALID_REQUEST
    ERROR
    NOT_FOUND
    NOT_AVAILABLE
}
```

#### StateSnapshotResponseCode

Response codes returned when querying state snapshots.

```
enum StateSnapshotResponseCode {
    UNKNOWN
    SUCCESS
    INVALID_REQUEST
    ERROR
}
```

#### BlockContentsProofResponseCode

Response codes returned when requesting block contents proofs.

```
enum BlockContentsProofResponseCode {
    UNKNOWN
    SUCCESS
    INVALID_REQUEST
    ERROR
    ITEM_NOT_FOUND
    NOT_AVAILABLE
    DUPLICATE_HASH_ITEM_FOUND
}
```

#### StateProofResponseCode

Response codes returned when requesting state proofs.

```
enum StateProofResponseCode {
    UNKNOWN
    SUCCESS
    KEY_NOT_FOUND
    NOT_AVAILABLE
}
```

#### BlockItemType

Types of items that can be contained in a block.

```
enum BlockItemType {
    BLOCK_HEADER
    EVENT_HEADER
    ROUND_HEADER
    SIGNED_TRANSACTION
    TRANSACTION_RESULT
    TRANSACTION_OUTPUT
    STATE_CHANGES
    FILTERED_SINGLE_ITEM
    BLOCK_PROOF
    RECORD_FILE
    TRACE_DATA
    BLOCK_FOOTER
    REDACTED_ITEM
}
```

---

### Data Types

#### Network & Configuration

##### BlockNodeEndpoint

Represents the network endpoint for a Block Node.

```
BlockNodeEndpoint {
    // The IP address (v4) of the Block Node
    @@nullable ipAddress: bytes

    // The port number for gRPC connections
    port: int32

    // The domain name of the Block Node (alternative to IP address)
    domainName: string

    // Create from a string in "host:port" format
    @@static BlockNodeEndpoint fromString(address: string)

    // Convert to string representation
    string toString()
}
```

##### BlockNodeVersions

Version information for a Block Node.

```
BlockNodeVersions {
    // A version of the Block Node network address book
    @@immutable addressBookVersion: SemanticVersion

    // A version of the Block Stream specification supported by this Block Node
    @@immutable streamProtoVersion: SemanticVersion

    // A version of the Block Node software
    @@immutable softwareVersion: SemanticVersion
}
```

##### BlockNodeInfo

Information about a Block Node's status and capabilities.

```
BlockNodeInfo {
    // The first block number available on this Block Node
    @@immutable firstAvailableBlock: uint64

    // The last block number available on this Block Node
    @@immutable lastAvailableBlock: uint64

    // A flag indicating this Block Node only offers the latest state snapshot.
    // If true, clients must set retrieveLatest=true in StateSnapshotQuery.
    @@immutable onlyLatestState: bool

    // Version information for address book, stream protocol, and software
    @@immutable versionInformation: BlockNodeVersions
}
```

#### Block Structure

##### BlockHashAlgorithm

Hash algorithm used for a block.

```
enum BlockHashAlgorithm {
    SHA2_384
}
```

##### BlockHeader

The header of a block containing metadata.

```
BlockHeader {
    // A version of the HAPI specification used to serialize the block
    @@immutable hapiProtoVersion: SemanticVersion

    // A version of the consensus node software that executed transactions in this block
    @@immutable softwareVersion: SemanticVersion

    // The block number (must be exactly 1 more than previous block)
    @@immutable number: uint64

    // The timestamp for this block (consensus time of first round in the block)
    @@immutable blockTimestamp: dateTime

    // The hash algorithm used for this block, including the block proof
    @@immutable hashAlgorithm: BlockHashAlgorithm
}
```

##### BlockItem

An individual item within a block.

```
@@oneOf(blockHeader, eventHeader, roundHeader, signedTransaction, transactionResult, transactionOutput, stateChanges, filteredSingleItem, blockProof, recordFile, traceData, blockFooter, redactedItem)
BlockItem {
    @@immutable @@nullable blockHeader: BlockHeader
    @@immutable @@nullable eventHeader: EventHeader
    @@immutable @@nullable roundHeader: RoundHeader
    @@immutable @@nullable signedTransaction: bytes
    @@immutable @@nullable transactionResult: TransactionResult
    @@immutable @@nullable transactionOutput: TransactionOutput
    @@immutable @@nullable stateChanges: StateChanges
    @@immutable @@nullable filteredSingleItem: FilteredSingleItem
    @@immutable @@nullable blockProof: BlockProof
    @@immutable @@nullable recordFile: RecordFileItem
    @@immutable @@nullable traceData: TraceData
    @@immutable @@nullable blockFooter: BlockFooter
    @@immutable @@nullable redactedItem: RedactedItem
}
```

##### EventCore

Core data for a network gossip event.

```
EventCore {
    // The unique identifier for the node that created the event
    @@immutable creatorNodeId: int64

    // The birth round of the event (pending consensus round when created)
    @@immutable birthRound: int64

    // The wall clock time when the latest information affecting this event was received
    @@immutable timeCreated: dateTime

    // A random number used to break ties in the consensus algorithm
    @@immutable coin: int64
}
```

##### ParentEventReference

A reference to a parent event in the consensus graph.

```
@@oneOf(eventDescriptor, index)
ParentEventReference {
    // An EventDescriptor for the parent event outside of the containing block
    @@immutable @@nullable eventDescriptor: EventDescriptor

    // An index of the parent event within the containing block
    @@immutable @@nullable index: uint32
}
```

Note: `EventDescriptor` is an existing protobuf type from the platform event specification that uniquely identifies an event.

##### EventHeader

A header for a single network gossip event, containing information about the event and its parents.

```
EventHeader {
    // Core event data including creator, birth round, and timestamp
    @@immutable eventCore: EventCore

    // List of references to parent events
    @@immutable parents: list<ParentEventReference>
}
```

##### RoundHeader

A header for a single consensus round, marking the start of a new round.

```
RoundHeader {
    // The round number assigned for consensus
    @@immutable roundNumber: uint64
}
```

##### TransactionResult

The result of running a transaction (receipt information).

```
TransactionResult {
    // The status code indicating success or a specific failure
    @@immutable status: ResponseCodeEnum

    // The consensus timestamp when this transaction reached consensus
    @@immutable consensusTimestamp: dateTime

    // The parent consensus timestamp for child transactions (null for user-submitted)
    @@immutable @@nullable parentConsensusTimestamp: dateTime

    // A schedule that executed this transaction, if scheduled
    @@immutable @@nullable scheduleRef: ScheduleId

    // The actual transaction fee charged (in tinybar)
    @@immutable transactionFeeCharged: uint64

    // All HBAR transfers completed as a result of this transaction
    @@immutable transferList: TransferList

    // All non-HBAR token transfers completed as a result of this transaction
    @@immutable tokenTransferLists: list<TokenTransferList>

    // Token associations created automatically during this transaction
    @@immutable automaticTokenAssociations: list<TokenAssociation>

    // Accounts paid staking rewards as a result of this transaction
    @@immutable paidStakingRewards: list<AccountAmount>

    // The congestion pricing multiplier applied to transaction fees
    @@immutable congestionPricingMultiplier: uint64

    // Custom fees assessed during transaction execution
    @@immutable assessedCustomFees: list<AssessedCustomFee>
}
```

Note: `ResponseCodeEnum`, `TransferList`, `TokenTransferList`, `TokenAssociation`, `AccountAmount`, `AssessedCustomFee`, and `ScheduleId` are existing SDK types.

##### TransactionOutput

Output from a transaction that is not in the transaction body or state changes.

```
@@oneOf(utilPrng, contractCall, ethereumCall, contractCreate, createSchedule, signSchedule, accountCreate)
TransactionOutput {
    // Output from a utilPrng transaction
    @@immutable @@nullable utilPrng: UtilPrngOutput

    // Output from a contract call transaction
    @@immutable @@nullable contractCall: CallContractOutput

    // Output from an ethereum call transaction
    @@immutable @@nullable ethereumCall: EthereumOutput

    // Output from a contract create transaction
    @@immutable @@nullable contractCreate: CreateContractOutput

    // Output from a schedule create transaction that executed immediately
    @@immutable @@nullable createSchedule: CreateScheduleOutput

    // Output from a schedule sign transaction that executed the scheduled transaction
    @@immutable @@nullable signSchedule: SignScheduleOutput

    // Output from a transaction that includes account creation
    @@immutable @@nullable accountCreate: CreateAccountOutput
}
```

Note: The specific output types (`UtilPrngOutput`, `CallContractOutput`, `EthereumOutput`, `CreateContractOutput`, `CreateScheduleOutput`, `SignScheduleOutput`, `CreateAccountOutput`) are service-specific types from the block stream specification.

##### StateChanges

A set of state changes that mutate network state at a specific consensus timestamp.

```
StateChanges {
    // The consensus timestamp of this set of changes
    @@immutable consensusTimestamp: dateTime

    // An ordered list of individual state changes (must be applied in order)
    @@immutable stateChanges: list<StateChange>
}
```

##### StateChange

A single change to an item in the network state merkle tree.

```
@@oneOf(stateAdd, stateRemove, singletonUpdate, mapUpdate, mapDelete, queuePush, queuePop)
StateChange {
    // A state identifier indicating which merkle subtree is being modified
    @@immutable stateId: uint32

    // Addition of a new state (singleton, virtual map, or queue)
    @@immutable @@nullable stateAdd: NewStateChange

    // Removal of an existing state
    @@immutable @@nullable stateRemove: RemovedStateChange

    // An add or update to a Singleton state
    @@immutable @@nullable singletonUpdate: SingletonUpdateChange

    // An add or update to a single item in a VirtualMap
    @@immutable @@nullable mapUpdate: MapUpdateChange

    // A removal of a single item from a VirtualMap
    @@immutable @@nullable mapDelete: MapDeleteChange

    // Addition of an item to a Queue state
    @@immutable @@nullable queuePush: QueuePushChange

    // Removal of an item from a Queue state
    @@immutable @@nullable queuePop: QueuePopChange
}
```

Note: The state change operation types (`NewStateChange`, `RemovedStateChange`, `SingletonUpdateChange`, `MapUpdateChange`, `MapDeleteChange`, `QueuePushChange`, `QueuePopChange`) are complex types that vary based on the state being modified. SDKs should expose these as appropriate wrapper types or provide accessor methods for common use cases.

##### SubMerkleTree

Identifier for each sub-tree of the block root fixed-size merkle tree.

```
enum SubMerkleTree {
    ITEM_TYPE_UNSPECIFIED
    PREVIOUS_BLOCK_ROOT
    PREVIOUS_ROOTS_TREE
    PREVIOUS_BLOCK_START_STATE
    CONSENSUS_HEADER_ITEMS
    INPUT_ITEMS_TREE
    OUTPUT_ITEMS_TREE
    STATE_CHANGE_ITEMS_TREE
    TRACE_DATA_ITEMS_TREE
}
```

##### FilteredSingleItem

A block item that was intentionally filtered from the stream.

```
FilteredSingleItem {
    // A hash of the item that was filtered from the stream
    @@immutable itemHash: bytes

    // Identifies which block merkle sub-tree the hash belongs to
    @@immutable tree: SubMerkleTree
}
```

##### RedactedItem

A block item that was intentionally redacted from the stream.

```
RedactedItem {
    // A hash of the item that was redacted from the stream
    @@immutable itemHash: bytes

    // Hash of the SignedTransaction directly (for event reconstruction), if applicable
    @@immutable @@nullable signedTransactionHash: bytes

    // Identifies which block merkle sub-tree the hash belongs to
    @@immutable tree: SubMerkleTree
}
```

##### BlockFooter

A collection of hashes at the end of each block, needed to compute the block's root hash.

```
BlockFooter {
    // The root hash of the previous block (empty for genesis block)
    @@immutable previousBlockRootHash: bytes

    // The root hash of a merkle tree containing all block hashes from block zero
    @@immutable rootHashOfAllBlockHashesTree: bytes

    // The merkle root hash of the network state at the start of the current block
    @@immutable startOfBlockStateRootHash: bytes
}
```

##### TraceData

Trace or debugging data for a transaction, such as EVM execution traces.

```
@@oneOf(evmTraceData, submitMessageTraceData)
TraceData {
    // EVM trace data for smart contract transactions
    @@immutable @@nullable evmTraceData: EvmTraceData

    // Trace data for ConsensusSubmitMessage transactions
    @@immutable @@nullable submitMessageTraceData: SubmitMessageTraceData
}
```

Note: `EvmTraceData` and `SubmitMessageTraceData` are service-specific trace types from the block stream specification.

##### RecordFileItem

A block item containing data from the legacy record stream format (pre-block stream).

```
RecordFileItem {
    // The consensus time the record file was produced for
    @@immutable creationTime: dateTime

    // The contents of a record file (version prefix + data)
    @@immutable recordFileContents: bytes

    // The contents of sidecar files for this block (zero or more)
    @@immutable sidecarFileContents: list<SidecarFile>

    // RSA signatures from consensus nodes validating the record file hash
    @@immutable recordFileSignatures: list<RecordFileSignature>
}
```

Note: `SidecarFile` is an existing protobuf type from the streams specification.

##### Block

A verified block from the block stream.

```
Block {
    // The block items contained in this block (begins with BlockHeader, ends with BlockProof)
    @@immutable items: list<BlockItem>

    // Convenience: Get the block header (first item of type BLOCK_HEADER)
    @@immutable @@nullable header: BlockHeader

    // Convenience: Get the block proof (last item of type BLOCK_PROOF)
    @@immutable @@nullable proof: BlockProof

    // Convenience: Get the block number from the header
    @@immutable @@nullable blockNumber: uint64

    // Convenience: Get all items of a specific type
    list<BlockItem> itemsByType(type: BlockItemType)
}
```

#### Merkle Tree Components

##### MerkleSiblingHash

A hash of a sibling in a Merkle tree, used to reconstruct parent hashes.

```
MerkleSiblingHash {
    // If true, this sibling is the first hash in the pair; if false, it is the second
    @@immutable isFirst: bool

    // The raw hash bytes of the sibling
    @@immutable siblingHash: bytes
}
```

##### SiblingNode

Represents a sibling node hash in a MerklePath.

```
SiblingNode {
    // True when this sibling is on the left of the merkle path
    @@immutable isLeft: bool

    // The hash of the sibling node
    @@immutable hash: bytes
}
```

##### MerklePath

A path from a node in a Merkle tree to the root of that tree.

```
@@oneOf(leaf, hash)
MerklePath {
    // Optional leaf, if this path starts from a leaf
    @@immutable @@nullable leaf: MerkleLeaf

    // Optional hash for a path with no leaf
    @@immutable @@nullable hash: bytes

    // Array of sibling nodes ordered from bottom of tree to top
    @@immutable siblings: list<SiblingNode>

    // Index of next parent path going up the tree (UINT32_MAX if root)
    @@immutable nextPathIndex: uint32
}
```

Note: `MerkleLeaf` is an existing protobuf type from the block stream specification. SDKs should expose it as an appropriate wrapper type.

#### Signature & Trust Types

##### RecordFileSignature

A signature by a node on the SHA384 hash of a record file.

```
RecordFileSignature {
    // RSA signature of the node on the SHA384 hash of the record file
    @@immutable signatureBytes: bytes

    // Node id of the consensus node that created this signature
    @@immutable nodeId: int32
}
```

##### AggregatedNodeSignatures

An aggregation of node signatures on some data.

```
AggregatedNodeSignatures {
    // The aggregated signature
    @@immutable aggregatedSignature: bytes

    // In ascending order, the ids of the nodes that contributed signatures
    @@immutable signingNodeIds: list<uint64>
}
```

##### TssSignedBlockProof

A proof containing a TSS signature for a single block.

```
TssSignedBlockProof {
    // TSS signature for one block (aggregated from nodes with >2/3 network weight)
    @@immutable blockSignature: bytes
}
```

##### SignedRecordFileProof

A proof containing RSA signatures from consensus nodes for a record file (backward compatibility).

```
SignedRecordFileProof {
    // Collection of RSA signatures from consensus nodes
    @@immutable recordFileSignatures: list<RecordFileSignature>
}
```

##### ChainOfTrustProof

Proof that a verification key belongs to the network's chain of trust.

```
@@oneOf(aggregatedNodeSignatures, wrapsProof)
ChainOfTrustProof {
    // Aggregation of Schnorr signatures (used until first recursive proof is available)
    @@immutable @@nullable aggregatedNodeSignatures: AggregatedNodeSignatures

    // ZK-compressed SNARK proof proving the chain of trust
    @@immutable @@nullable wrapsProof: bytes
}
```

#### Proof Types

##### BlockStateProof

A state proof that cryptographically proves nodes in the block merkle tree.

```
@@oneOf(signedBlockProof, signedRecordFileProof)
BlockStateProof {
    // Merkle paths that prove the nodes in the block merkle tree
    @@immutable paths: list<MerklePath>

    // TSS signature proof for a block (oneof proof)
    @@immutable @@nullable signedBlockProof: TssSignedBlockProof

    // RSA signatures proof for a record file (oneof proof)
    @@immutable @@nullable signedRecordFileProof: SignedRecordFileProof
}
```

##### BlockProof

Cryptographic proof for the Block Merkle Tree.

```
@@oneOf(signedBlockProof, blockStateProof, signedRecordFileProof)
BlockProof {
    // The block number this proof secures
    @@immutable block: uint64

    // Sibling hashes forming the Merkle proof path from block root to signed root
    // Empty if this is a "direct" signature
    @@immutable siblingHashes: list<MerkleSiblingHash>

    // The hinTS verification key (verify after checking chain of trust proof)
    @@immutable verificationKey: bytes

    // Proof the hinTS verification key is in the chain of trust
    @@immutable verificationKeyProof: ChainOfTrustProof

    // TSS signature over the block's merkle root hash (oneof proof)
    @@immutable @@nullable signedBlockProof: TssSignedBlockProof

    // Proof of the block merkle tree's contents (oneof proof)
    @@immutable @@nullable blockStateProof: BlockStateProof

    // RSA signatures from consensus nodes for backward compatibility (oneof proof)
    @@immutable @@nullable signedRecordFileProof: SignedRecordFileProof
}
```

##### BlockContentsProof

Cryptographic proof that a specific item was included in a block.

```
BlockContentsProof {
    // The block item that is proved
    @@immutable blockItem: BlockItem

    // Sibling hashes forming the Merkle proof for verifying the block item
    @@immutable siblingHashes: list<MerkleSiblingHash>

    // The digital signature over the block content proof data
    @@immutable blockSignature: bytes
}
```

##### StateProof

Cryptographic proof of a state value at a specific block.

```
StateProof {
    // The block number at which the proof is requested
    @@immutable blockNumber: uint64

    // The value of the state item proved
    @@immutable value: bytes

    // Sibling hashes forming the Merkle proof for verifying the state item
    @@immutable siblingHashes: list<MerkleSiblingHash>

    // The digital signature over the state proof data
    @@immutable blockSignature: bytes
}
```

#### Query Response Types

##### StateSnapshot

Reference to a state snapshot at a specific block.

```
StateSnapshot {
    // The block number of the last block included in this state snapshot
    @@immutable lastBlockNumber: uint64

    // A reference to where the state snapshot may be obtained
    // (format is implementation-defined: URL, cloud storage reference, etc.)
    @@immutable snapshotReference: string
}
```

---

### Abstract Query Types

#### BlockNodeQuery

Abstract base type for Block Node queries that return a single response. Provides common configuration and execution patterns for all Block Node queries.

```
abstraction BlockNodeQuery<$$Response> {
    // Set the gRPC deadline for this query (overrides client default)
    $$Self setGrpcDeadline(deadline: TimeInterval)

    // Get the gRPC deadline
    @@nullable TimeInterval getGrpcDeadline()

    // Execute the query against the client's Block Node network
    @@async
    @@throws(block-node-error)
    $$Response execute(client: Client)
}
```

---

### Queries

#### ServerStatusQuery

Query the status and capabilities of a Block Node.

```
ServerStatusQuery extends BlockNodeQuery<BlockNodeInfo> {
    // No additional configuration - uses inherited execute() and setGrpcDeadline()
}
```

#### BlockQuery

Retrieve a single block by block number or the latest block.

```
BlockQuery extends BlockNodeQuery<Block> {
    // Set the block number to retrieve (use this OR setRetrieveLatest, not both)
    // May specify uint64_max to request the last possible block
    BlockQuery setBlockNumber(blockNumber: uint64)

    // Get the block number
    @@nullable uint64 getBlockNumber()

    // Set whether to retrieve the latest available block (use this OR setBlockNumber, not both)
    BlockQuery setRetrieveLatest(retrieveLatest: bool)

    // Get whether to retrieve the latest block
    bool getRetrieveLatest()
}
```

Note: `execute()` may throw `block-not-found-error` or `block-not-available-error` in addition to the base `block-node-error`.

#### BlockStreamQuery

Subscribe to a stream of blocks from a Block Node. This follows the pattern of `TopicMessageQuery` in the SDK, returning an async sequence that can be iterated.

```
BlockStreamQuery {
    // Set the starting block number (required)
    BlockStreamQuery setStartBlockNumber(startBlockNumber: uint64)

    // Get the starting block number
    uint64 getStartBlockNumber()

    // Set the ending block number (optional, uint64_max for indefinite streaming)
    BlockStreamQuery setEndBlockNumber(endBlockNumber: uint64)

    // Get the ending block number
    @@nullable uint64 getEndBlockNumber()

    // Subscribe and return an async sequence of blocks
    // The sequence continues until endBlockNumber is reached, the stream is cancelled,
    // or an error occurs
    @@async
    AsyncSequence<Block> subscribe(client: Client, @@nullable timeout: TimeInterval)

    // Execute and collect all blocks in the range (only valid with endBlockNumber set)
    @@async
    @@throws(block-node-error)
    list<Block> execute(client: Client, @@nullable timeout: TimeInterval)
}
```

#### StateSnapshotQuery

Query for a state snapshot at a specific block or the latest available.

```
StateSnapshotQuery extends BlockNodeQuery<StateSnapshot> {
    // Set the last block number to include in the snapshot (optional)
    // If retrieveLatest is true, this field is ignored
    StateSnapshotQuery setLastBlockNumber(blockNumber: uint64)

    // Get the last block number
    @@nullable uint64 getLastBlockNumber()

    // Set whether to retrieve the latest available snapshot (optional, default false)
    // Some Block Nodes may require this to be true (check onlyLatestState in BlockNodeInfo)
    StateSnapshotQuery setRetrieveLatest(retrieveLatest: bool)

    // Get whether to retrieve the latest snapshot
    bool getRetrieveLatest()
}
```

Note: `execute()` may throw `state-not-available-error` in addition to the base `block-node-error`.

#### BlockContentsProofQuery

Request a cryptographic proof for a specific item in a block. Exactly one of `blockItem`, `blockItemHash`, or `blockItemIndex` must be set.

```
BlockContentsProofQuery extends BlockNodeQuery<BlockContentsProof> {
    // Set the block number containing the item (required)
    BlockContentsProofQuery setBlockNumber(blockNumber: uint64)

    // Get the block number
    uint64 getBlockNumber()

    // Set the complete block item to generate proof for (use this OR hash OR index)
    BlockContentsProofQuery setBlockItem(blockItem: BlockItem)

    // Get the block item
    @@nullable BlockItem getBlockItem()

    // Set the item hash (use this OR blockItem OR index)
    // Use when the block item is identified by its hash and there is only one match
    BlockContentsProofQuery setBlockItemHash(itemHash: bytes)

    // Get the item hash
    @@nullable bytes getBlockItemHash()

    // Set the item index within the block (use this OR blockItem OR hash)
    // Use when there are multiple items with the same hash
    BlockContentsProofQuery setBlockItemIndex(itemIndex: uint32)

    // Get the item index
    @@nullable uint32 getBlockItemIndex()
}
```

Note: `execute()` may throw `proof-not-available-error`, `item-not-found-error`, or `duplicate-hash-error` in addition to the base `block-node-error`.

#### StateProofQuery

Request a cryptographic proof for a state value at a specific block.

```
StateProofQuery extends BlockNodeQuery<StateProof> {
    // Set the block number at which to prove the state (required)
    StateProofQuery setBlockNumber(blockNumber: uint64)

    // Get the block number
    uint64 getBlockNumber()

    // Set the state key to prove (required)
    StateProofQuery setStateKey(stateKey: bytes)

    // Get the state key
    bytes getStateKey()
}
```

Note: `execute()` may throw `proof-not-available-error` or `key-not-found-error` in addition to the base `block-node-error`.

---

## Updated APIs

### Client

The existing `Client` class is extended with Block Node network management, following the same pattern used for Mirror Network configuration.

```
Client {
    // Get the Block Node network addresses
    list<string> getBlockNodeNetwork()

    // Set the Block Node network addresses
    Client setBlockNodeNetwork(addresses: list<string>)

    // Update the Block Node network from a Block Node address book
    Client setBlockNodeNetworkFromAddressBook(addressBook: BlockNodeAddressBook)

    // Create a client bootstrapped from Block Node network only
    // Useful when only Block Node access is needed (no transaction submission)
    @@static
    @@async
    Client forBlockNodeNetwork(addresses: list<string>)
}
```

---

## Internal Changes

### Abstract Query Implementation

The `BlockNodeQuery` abstraction provides:

1. **Common Configuration**: gRPC deadline settings inherited by all request/response queries
2. **Execution Logic**: Connection to Block Node network, retry handling, error mapping
3. **Type Safety**: Generic response types ensure compile-time type checking

SDKs should implement this abstraction following their language's idiomatic patterns for generic abstract types.

Note: `BlockStreamQuery` is a standalone class (not extending `BlockNodeQuery`) since streaming queries have different execution patterns (`subscribe()` vs `execute()`). If additional streaming query types are needed in the future, a common abstraction can be introduced at that time.

### Block Node Network Management

The SDK manages Block Node connections similarly to how it manages Mirror Network connections:

1. **Connection Management**: Internal component managing gRPC channels to Block Nodes.

2. **Connection Pooling**: Block Node connections are pooled and load-balanced across configured endpoints.

3. **Health Tracking**: Failed Block Node connections are tracked and temporarily removed from the pool, similar to consensus node health tracking.

4. **Channel Reuse**: Reuse existing gRPC channel infrastructure and TLS configuration patterns from the SDK.

### Query Execution

Block Node queries follow the existing `MirrorQuery` pattern:

1. Queries execute against the client's Block Node network
2. If no Block Node network is configured, queries throw a descriptive error
3. Retry logic follows the same exponential backoff pattern as other queries
4. Streaming queries (`BlockStreamQuery`) use `AsyncSequence` like `TopicMessageQuery`

### Error Handling

Block Node errors are surfaced using each SDK's existing error pattern. The following error cases should be added:

| Error | Description |
|-------|-------------|
| `blockNodeNetworkNotConfigured` | Block Node query attempted without configuring Block Node network |
| `blockNodeGrpcStatus` | gRPC error from Block Node (includes status code) |
| `blockNotFound` | Requested block does not exist |
| `blockNotAvailable` | Requested block exists but is not available on this node |
| `stateNotAvailable` | State snapshot not available for the requested block |
| `proofNotAvailable` | Proof generation not available for the requested block |
| `blockItemNotFound` | Specified block item was not found |
| `stateKeyNotFound` | Specified state key was not found |
| `duplicateHashItem` | Multiple items match the provided hash |
| `invalidBlockRange` | Invalid block range (e.g., end before start) |

### Response Codes

The following response codes may be returned by Block Node services:

**Subscribe Stream Response Codes:**
- `UNKNOWN` - Server software failed to set a status
- `SUCCESS` - Request succeeded
- `INVALID_REQUEST` - Malformed or structurally incorrect request
- `ERROR` - Block Node encountered an error
- `INVALID_START_BLOCK_NUMBER` - Requested start block is not valid
- `INVALID_END_BLOCK_NUMBER` - Requested end block is not valid
- `NOT_AVAILABLE` - Requested stream is not available

**Block Access Response Codes:**
- `UNKNOWN` - Server software failed to set a status
- `SUCCESS` - Request succeeded
- `INVALID_REQUEST` - Malformed request
- `ERROR` - Block Node encountered an error
- `NOT_FOUND` - Block does not exist
- `NOT_AVAILABLE` - Block not currently available on this node

**State Snapshot Response Codes:**
- `UNKNOWN` - Server software failed to set a status
- `SUCCESS` - Request succeeded
- `INVALID_REQUEST` - Malformed request
- `ERROR` - Block Node encountered an error

**Block Contents Proof Response Codes:**
- `UNKNOWN` - Server software failed to set a status
- `SUCCESS` - Request succeeded
- `INVALID_REQUEST` - Malformed request
- `ERROR` - Block Node encountered an error
- `ITEM_NOT_FOUND` - Specified block item was not found
- `NOT_AVAILABLE` - Proof not available for specified block
- `DUPLICATE_HASH_ITEM_FOUND` - Duplicate hash items found, use item index instead

**State Proof Response Codes:**
- `UNKNOWN` - Server software failed to set a status
- `SUCCESS` - Request succeeded
- `KEY_NOT_FOUND` - Specified state key was not found
- `NOT_AVAILABLE` - State proof not available for specified block

#### Transaction Retry

Block Node APIs do not directly involve transaction submission. However, SDKs should implement retry logic for:
- `INTERNAL_ERROR` - Retry with exponential backoff
- `NOT_AVAILABLE` - Retry after short delay or rotate to another Block Node
- gRPC `UNAVAILABLE`, `RESOURCE_EXHAUSTED` - Retry with exponential backoff

---

## Test Plan

### Client Block Node Configuration

1. **Given** a `Client` instance, **when** `setBlockNodeNetwork()` is called with valid addresses, **then** the Block Node network is configured and subsequent Block Node queries succeed.

2. **Given** a `Client` instance with no Block Node network configured, **when** a Block Node query is executed, **then** an error indicating "Block Node network not configured" is thrown.

3. **Given** valid Block Node addresses, **when** `Client.forBlockNodeNetwork()` is called, **then** a client is created with only Block Node connectivity (no consensus/mirror networks).

4. **Given** a `Client` with Block Node network configured, **when** `blockNodeNetwork` property is accessed, **then** the configured addresses are returned.

### ServerStatusQuery

5. **Given** a `Client` with Block Node network configured, **when** `ServerStatusQuery().execute(client)` is called, **then** a `BlockNodeInfo` is returned containing `firstAvailableBlock`, `lastAvailableBlock`, `onlyLatestState`, and `versionInformation`.

6. **Given** a `Client` connected to an unreachable Block Node, **when** `ServerStatusQuery().execute(client)` is called, **then** an error is thrown after retry attempts are exhausted.

### BlockQuery

7. **Given** a valid block number within the node's available range, **when** `BlockQuery().setBlockNumber(n).execute(client)` is called, **then** a `Block` is returned with header, items, and proof.

8. **Given** a block number that does not exist, **when** `BlockQuery().setBlockNumber(n).execute(client)` is called, **then** a `block-not-found-error` is thrown.

9. **Given** a block number outside the node's available range, **when** `BlockQuery().setBlockNumber(n).execute(client)` is called, **then** a `block-not-available-error` is thrown.

10. **Given** a `Block` returned from a query, **when** `itemsByType(.transactionResult)` is called, **then** only transaction result items are returned.

11. **Given** a `BlockQuery`, **when** `setRetrieveLatest(true).execute(client)` is called, **then** the latest available block is returned.

### BlockStreamQuery

12. **Given** a valid start block number, **when** `BlockStreamQuery().setStartBlockNumber(n).subscribe(client)` is called, **then** an async sequence is returned that yields blocks starting from block n.

13. **Given** an active block stream subscription, **when** iterating with `for await block in stream`, **then** blocks are received in order.

14. **Given** a block stream with start and end block numbers, **when** the end block is reached, **then** the async sequence completes normally.

15. **Given** a block stream subscription with no end block, **when** new blocks are produced, **then** they are received in the stream until cancelled.

16. **Given** an invalid start block number (greater than available), **when** `BlockStreamQuery().setStartBlockNumber(n).subscribe(client)` is called, **then** an error with `INVALID_START_BLOCK_NUMBER` is thrown.

17. **Given** an end block less than start block, **when** `BlockStreamQuery().setStartBlockNumber(10).setEndBlockNumber(5).subscribe(client)` is called, **then** an error with `INVALID_END_BLOCK_NUMBER` is thrown.

18. **Given** a start and end block number, **when** `BlockStreamQuery().setStartBlockNumber(n).setEndBlockNumber(m).execute(client)` is called, **then** all blocks in the range are collected and returned as a list.

### StateSnapshotQuery

19. **Given** a Block Node that supports state snapshots, **when** `StateSnapshotQuery().setRetrieveLatest(true).execute(client)` is called, **then** the latest `StateSnapshot` is returned.

20. **Given** a Block Node that supports state snapshots and a valid block number, **when** `StateSnapshotQuery().setLastBlockNumber(n).execute(client)` is called, **then** a `StateSnapshot` for that block is returned.

21. **Given** a Block Node with `onlyLatestState=true`, **when** `StateSnapshotQuery().setLastBlockNumber(n).execute(client)` is called (without `retrieveLatest=true`), **then** an error is thrown.

22. **Given** a block number that has no snapshot, **when** `StateSnapshotQuery().setLastBlockNumber(n).execute(client)` is called, **then** an error is thrown.

### BlockContentsProofQuery

23. **Given** a valid block number and item index, **when** `BlockContentsProofQuery().setBlockNumber(n).setBlockItemIndex(i).execute(client)` is called, **then** a `BlockContentsProof` is returned.

24. **Given** an invalid item index, **when** `BlockContentsProofQuery().setBlockNumber(n).setBlockItemIndex(999).execute(client)` is called, **then** an `item-not-found-error` is thrown.

25. **Given** a valid item hash, **when** `BlockContentsProofQuery().setBlockNumber(n).setBlockItemHash(hash).execute(client)` is called, **then** a `BlockContentsProof` is returned.

26. **Given** a hash matching multiple items, **when** `BlockContentsProofQuery().setBlockNumber(n).setBlockItemHash(hash).execute(client)` is called, **then** a `duplicate-hash-error` is thrown (client should use `setBlockItemIndex` instead).

27. **Given** a Block Node that does not support proofs, **when** `BlockContentsProofQuery().setBlockNumber(n).setBlockItemIndex(i).execute(client)` is called, **then** a `proof-not-available-error` is thrown.

### StateProofQuery

28. **Given** a valid block number and state key, **when** `StateProofQuery().setBlockNumber(n).setStateKey(key).execute(client)` is called, **then** a `StateProof` is returned.

29. **Given** a non-existent state key, **when** `StateProofQuery().setBlockNumber(n).setStateKey(key).execute(client)` is called, **then** a `key-not-found-error` is thrown.

30. **Given** a block that doesn't support state proofs, **when** `StateProofQuery().setBlockNumber(n).setStateKey(key).execute(client)` is called, **then** a `proof-not-available-error` is thrown.

### Error Handling and Resilience

31. **Given** a `Client` experiencing transient Block Node connection errors, **when** any Block Node query is executed, **then** the SDK retries with exponential backoff before failing.

32. **Given** a block stream subscription that loses connection, **when** reconnection succeeds, **then** streaming resumes from the last received block number.

33. **Given** a `Client` with multiple Block Node addresses configured, **when** one Block Node becomes unhealthy, **then** queries are routed to healthy Block Nodes.

### TCK

The tests defined above should be implemented in the [TCK repository](https://github.com/hiero-ledger/hiero-sdk-tck). Issues should be created to track:
- Client Block Node configuration tests
- Block access and retrieval tests
- Block stream subscription tests
- State snapshot query tests
- Proof generation and verification tests
- Error handling and resilience tests

---

## SDK Example

### Subscribing to Real-Time Block Stream

This example demonstrates how to connect to a Block Node and subscribe to a live block stream, following patterns established by `TopicMessageQuery`:

1. Create a client and configure the operator
2. Configure the Block Node network addresses
3. Query Block Node status to understand available data
4. Subscribe to the block stream starting from the latest block
5. Process blocks as they arrive in the async stream

### Using Block Nodes Alongside Consensus Operations

This example shows how Block Node queries work alongside regular transaction submission:

1. Create a fully configured client with operator and Block Node network
2. Submit a transaction via Consensus Network
3. Wait for block to be available
4. Query recent blocks from Block Node

### Retrieving Historical Blocks

This example shows how to retrieve specific historical blocks:

1. Create a client with only Block Node access (no operator needed for read-only operations)
2. Get a specific block by number
3. Examine the block header and proof
4. Get a range of blocks

### Obtaining Cryptographic Proofs

This example demonstrates requesting proofs for verification:

1. Create a client with Block Node access
2. Get a block contents proof for a specific item
3. Get a state proof for a specific key at a block

### Querying State Snapshots

This example shows how to obtain state snapshot references:

1. Create a client with Block Node access
2. Check if the Block Node only supports the latest state snapshot (via `onlyLatestState`)
3. Get the latest state snapshot using `setRetrieveLatest(true)`
4. If supported, get a state snapshot at a specific block using `setLastBlockNumber(n)`

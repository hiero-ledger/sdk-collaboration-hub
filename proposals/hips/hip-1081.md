# HIP-1081: Block Node SDK Integration

## Summary

HIP-1081 introduces Block Nodes as a decentralized data layer for the Hiero network. Block Nodes receive block streams from Consensus Nodes, verify block integrity, store the blockchain, and distribute blocks to downstream clients such as Mirror Nodes, dApps, and other Block Nodes.

This design document defines the SDK APIs required for applications to interact with Block Nodes. The SDK enables developers to:
- Subscribe to real-time and historical block streams
- Query Block Node status and capabilities
- Retrieve specific blocks by number
- Request state snapshots
- Obtain cryptographic proofs for blocks and state data

Block Node connectivity is integrated into the existing `Client` class, following the established pattern where the `Client` manages connections to multiple network components (Consensus Nodes, Mirror Nodes, and now Block Nodes). This provides a consistent, unified experience for SDK users.

**HIP:** https://hips.hedera.com/hip/hip-1081

**Related HIPs:**
- [HIP-1056: Block Streams](https://hips.hedera.com/hip/hip-1056)
- [HIP-1137: Block Node Discoverability](https://github.com/hiero-ledger/hiero-improvement-proposals/pull/1137)
- [HIP-1183: The hinTS threshold signature scheme](https://github.com/hiero-ledger/hiero-improvement-proposals/pull/1200)

**Date Submitted:** 2025-01-07

---

## New APIs

### Enumerations

#### SubscribeStreamResponseCode

Response codes returned when subscribing to a block stream.

```
enum SubscribeStreamResponseCode {
    UNKNOWN
    SUCCESS
    INVALID_REQUEST
    ERROR
    INVALID_START_BLOCK_NUMBER
    INVALID_END_BLOCK_NUMBER
    NOT_AVAILABLE
}
```

#### BlockAccessResponseCode

Response codes returned when accessing a single block.

```
enum BlockAccessResponseCode {
    UNKNOWN
    SUCCESS
    INVALID_REQUEST
    ERROR
    NOT_FOUND
    NOT_AVAILABLE
}
```

#### StateSnapshotResponseCode

Response codes returned when querying state snapshots.

```
enum StateSnapshotResponseCode {
    UNKNOWN
    SUCCESS
    INVALID_REQUEST
    ERROR
}
```

#### BlockContentsProofResponseCode

Response codes returned when requesting block contents proofs.

```
enum BlockContentsProofResponseCode {
    UNKNOWN
    SUCCESS
    INVALID_REQUEST
    ERROR
    ITEM_NOT_FOUND
    NOT_AVAILABLE
    DUPLICATE_HASH_ITEM_FOUND
}
```

#### StateProofResponseCode

Response codes returned when requesting state proofs.

```
enum StateProofResponseCode {
    UNKNOWN
    SUCCESS
    KEY_NOT_FOUND
    NOT_AVAILABLE
}
```

#### BlockItemType

Types of items that can be contained in a block. Based on the `BlockItem` protobuf `oneof item` field.

```
enum BlockItemType {
    BLOCK_HEADER
    EVENT_HEADER
    ROUND_HEADER
    SIGNED_TRANSACTION
    TRANSACTION_RESULT
    TRANSACTION_OUTPUT
    STATE_CHANGES
    FILTERED_SINGLE_ITEM
    BLOCK_PROOF
    RECORD_FILE
    TRACE_DATA
    BLOCK_FOOTER
    REDACTED_ITEM
}
```

---

### Data Types

#### BlockNodeEndpoint

Represents the network endpoint for a Block Node.

```
BlockNodeEndpoint {
    // The IP address (v4) of the Block Node
    @@nullable ipAddress: bytes

    // The port number for gRPC connections
    port: int32

    // The domain name of the Block Node (alternative to IP address)
    domainName: string

    // Create from a string in "host:port" format
    @@static BlockNodeEndpoint fromString(address: string)

    // Convert to string representation
    string toString()
}
```

#### SemanticVersion

A semantic version number (already exists in SDKs, included for reference).

```
SemanticVersion {
    @@immutable major: int32
    @@immutable minor: int32
    @@immutable patch: int32

    @@static SemanticVersion fromProtobuf(proto: proto.SemanticVersion)
    proto.SemanticVersion toProtobuf()
}
```

#### BlockNodeVersions

Version information for a Block Node. Maps to `BlockNodeVersions` protobuf.

```
BlockNodeVersions {
    // A version of the Block Node network address book
    @@immutable addressBookVersion: SemanticVersion

    // A version of the Block Stream specification supported by this Block Node
    @@immutable streamProtoVersion: SemanticVersion

    // A version of the Block Node software
    @@immutable softwareVersion: SemanticVersion

    @@static BlockNodeVersions fromProtobuf(proto: proto.BlockNodeVersions)
}
```

#### BlockNodeInfo

Information about a Block Node's status and capabilities, returned by the `serverStatus` API. Maps to `ServerStatusResponse` protobuf.

```
BlockNodeInfo {
    // The first block number available on this Block Node
    @@immutable firstAvailableBlock: uint64

    // The last block number available on this Block Node
    @@immutable lastAvailableBlock: uint64

    // A flag indicating this Block Node only offers the latest state snapshot.
    // If true, clients must set retrieveLatest=true in StateSnapshotQuery.
    @@immutable onlyLatestState: bool

    // Version information for address book, stream protocol, and software
    @@immutable versionInformation: BlockNodeVersions

    @@static BlockNodeInfo fromProtobuf(proto: proto.ServerStatusResponse)
}
```

#### Block

A verified block from the block stream. Maps to `Block` protobuf message.

```
Block {
    // The block items contained in this block (begins with BlockHeader, ends with BlockProof)
    @@immutable items: list<BlockItem>

    // Convenience: Get the block header (first item of type BLOCK_HEADER)
    @@immutable @@nullable header: BlockHeader

    // Convenience: Get the block proof (last item of type BLOCK_PROOF)
    @@immutable @@nullable proof: BlockProof

    // Convenience: Get the block number from the header
    @@immutable @@nullable blockNumber: uint64

    // Convenience: Get all items of a specific type
    list<BlockItem> itemsByType(type: BlockItemType)

    @@static Block fromProtobuf(proto: proto.Block)
}
```

#### BlockHashAlgorithm

Hash algorithm used for a block. Maps to `BlockHashAlgorithm` protobuf enum.

```
enum BlockHashAlgorithm {
    SHA2_384
}
```

#### BlockHeader

The header of a block containing metadata. Maps to `BlockHeader` protobuf message.

```
BlockHeader {
    // A version of the HAPI specification used to serialize the block
    @@immutable hapiProtoVersion: SemanticVersion

    // A version of the consensus node software that executed transactions in this block
    @@immutable softwareVersion: SemanticVersion

    // The block number (must be exactly 1 more than previous block)
    @@immutable number: uint64

    // The timestamp for this block (consensus time of first round in the block)
    @@immutable blockTimestamp: dateTime

    // The hash algorithm used for this block, including the block proof
    @@immutable hashAlgorithm: BlockHashAlgorithm

    @@static BlockHeader fromProtobuf(proto: proto.BlockHeader)
}
```

#### MerkleSiblingHash

A hash of a sibling in a Merkle tree, used to reconstruct parent hashes. Maps to `MerkleSiblingHash` protobuf message.

```
MerkleSiblingHash {
    // If true, this sibling is the first hash in the pair; if false, it is the second
    @@immutable isFirst: bool

    // The raw hash bytes of the sibling
    @@immutable siblingHash: bytes

    @@static MerkleSiblingHash fromProtobuf(proto: proto.MerkleSiblingHash)
}
```

#### BlockProof

Cryptographic proof for the Block Merkle Tree. Maps to `BlockProof` protobuf message.

```
BlockProof {
    // The block number this proof secures
    @@immutable block: uint64

    // Sibling hashes forming the Merkle proof path from block root to signed root
    // Empty if this is a "direct" signature
    @@immutable siblingHashes: list<MerkleSiblingHash>

    // The hinTS verification key (verify after checking chain of trust proof)
    @@immutable verificationKey: bytes

    // Proof the hinTS verification key is in the chain of trust
    @@immutable verificationKeyProof: ChainOfTrustProof

    // The proof type (oneof: signedBlockProof, blockStateProof, or signedRecordFileProof)
    @@immutable proofType: BlockProofType

    @@static BlockProof fromProtobuf(proto: proto.BlockProof)
}
```

#### BlockProofType

The type of proof contained in a BlockProof. Based on `BlockProof` protobuf `oneof proof` field.

```
enum BlockProofType {
    TSS_SIGNED_BLOCK_PROOF
    BLOCK_STATE_PROOF
    SIGNED_RECORD_FILE_PROOF
}
```

#### BlockItem

An individual item within a block. Maps to `BlockItem` protobuf message. The item is a `oneof` containing one of the `BlockItemType` values.

```
BlockItem {
    // The type of this block item (derived from which oneof field is set)
    @@immutable itemType: BlockItemType

    // Access the item as a BlockHeader (if itemType is BLOCK_HEADER)
    @@immutable @@nullable blockHeader: BlockHeader

    // Access the item as an EventHeader (if itemType is EVENT_HEADER)
    @@immutable @@nullable eventHeader: EventHeader

    // Access the item as a RoundHeader (if itemType is ROUND_HEADER)
    @@immutable @@nullable roundHeader: RoundHeader

    // Access the item as signed transaction bytes (if itemType is SIGNED_TRANSACTION)
    @@immutable @@nullable signedTransaction: bytes

    // Access the item as a TransactionResult (if itemType is TRANSACTION_RESULT)
    @@immutable @@nullable transactionResult: TransactionResult

    // Access the item as a TransactionOutput (if itemType is TRANSACTION_OUTPUT)
    @@immutable @@nullable transactionOutput: TransactionOutput

    // Access the item as StateChanges (if itemType is STATE_CHANGES)
    @@immutable @@nullable stateChanges: StateChanges

    // Access the item as a BlockProof (if itemType is BLOCK_PROOF)
    @@immutable @@nullable blockProof: BlockProof

    // Access the item as a BlockFooter (if itemType is BLOCK_FOOTER)
    @@immutable @@nullable blockFooter: BlockFooter

    // Access the item as TraceData (if itemType is TRACE_DATA)
    @@immutable @@nullable traceData: TraceData

    // Access the filtered item hash (if itemType is FILTERED_SINGLE_ITEM)
    @@immutable @@nullable filteredItemHash: bytes

    // Access the redacted item hash (if itemType is REDACTED_ITEM)
    @@immutable @@nullable redactedItemHash: bytes

    @@static BlockItem fromProtobuf(proto: proto.BlockItem)
    proto.BlockItem toProtobuf()
}
```

Note: `EventHeader`, `RoundHeader`, `TransactionResult`, `TransactionOutput`, `StateChanges`, `BlockFooter`, and `TraceData` are existing protobuf types from the block stream specification (HIP-1056). SDKs should expose these as appropriate wrapper types.

#### StateSnapshot

Reference to a state snapshot at a specific block. Maps to `StateSnapshotResponse` protobuf message.

```
StateSnapshot {
    // The block number of the last block included in this state snapshot
    @@immutable lastBlockNumber: uint64

    // A reference to where the state snapshot may be obtained
    // (format is implementation-defined: URL, cloud storage reference, etc.)
    @@immutable snapshotReference: string

    @@static StateSnapshot fromProtobuf(proto: proto.StateSnapshotResponse)
}
```

#### BlockContentsProof

Cryptographic proof that a specific item was included in a block. Maps to `BlockContentsProof` protobuf message.

```
BlockContentsProof {
    // The block item that is proved
    @@immutable blockItem: BlockItem

    // Sibling hashes forming the Merkle proof for verifying the block item
    @@immutable siblingHashes: list<MerkleSiblingHash>

    // The digital signature over the block content proof data
    @@immutable blockSignature: bytes

    @@static BlockContentsProof fromProtobuf(proto: proto.BlockContentsProof)
}
```

#### StateProof

Cryptographic proof of a state value at a specific block. Maps to `StateProof` protobuf message.

```
StateProof {
    // The block number at which the proof is requested
    @@immutable blockNumber: uint64

    // The value of the state item proved
    @@immutable value: bytes

    // Sibling hashes forming the Merkle proof for verifying the state item
    @@immutable siblingHashes: list<MerkleSiblingHash>

    // The digital signature over the state proof data
    @@immutable blockSignature: bytes

    @@static StateProof fromProtobuf(proto: proto.StateProof)
}
```

---

### Abstract Query Types

#### BlockNodeQuery

Abstract base type for Block Node queries that return a single response. Provides common configuration and execution patterns for all Block Node queries.

```
abstraction BlockNodeQuery<$$Response> {
    // Set the gRPC deadline for this query (overrides client default)
    $$Self setGrpcDeadline(deadline: TimeInterval)

    // Get the gRPC deadline
    @@nullable TimeInterval getGrpcDeadline()

    // Execute the query against the client's Block Node network
    @@async
    @@throws(block-node-error)
    $$Response execute(client: Client)
}
```

---

### Queries

#### ServerStatusQuery

Query the status and capabilities of a Block Node.

```
ServerStatusQuery extends BlockNodeQuery<BlockNodeInfo> {
    // No additional configuration - uses inherited execute() and setGrpcDeadline()
}
```

#### BlockQuery

Retrieve a single block by block number or the latest block.

```
BlockQuery extends BlockNodeQuery<Block> {
    // Set the block number to retrieve (use this OR setRetrieveLatest, not both)
    // May specify uint64_max to request the last possible block
    BlockQuery setBlockNumber(blockNumber: uint64)

    // Get the block number
    @@nullable uint64 getBlockNumber()

    // Set whether to retrieve the latest available block (use this OR setBlockNumber, not both)
    BlockQuery setRetrieveLatest(retrieveLatest: bool)

    // Get whether to retrieve the latest block
    bool getRetrieveLatest()
}
```

Note: `execute()` may throw `block-not-found-error` or `block-not-available-error` in addition to the base `block-node-error`.

#### BlockStreamQuery

Subscribe to a stream of blocks from a Block Node. This follows the pattern of `TopicMessageQuery` in the SDK, returning an async sequence that can be iterated.

```
BlockStreamQuery {
    // Set the starting block number (required)
    BlockStreamQuery setStartBlockNumber(startBlockNumber: uint64)

    // Get the starting block number
    uint64 getStartBlockNumber()

    // Set the ending block number (optional, uint64_max for indefinite streaming)
    BlockStreamQuery setEndBlockNumber(endBlockNumber: uint64)

    // Get the ending block number
    @@nullable uint64 getEndBlockNumber()

    // Subscribe and return an async sequence of blocks
    // The sequence continues until endBlockNumber is reached, the stream is cancelled,
    // or an error occurs
    @@async
    AsyncSequence<Block> subscribe(client: Client, @@nullable timeout: TimeInterval)

    // Execute and collect all blocks in the range (only valid with endBlockNumber set)
    @@async
    @@throws(block-node-error)
    list<Block> execute(client: Client, @@nullable timeout: TimeInterval)
}
```

#### StateSnapshotQuery

Query for a state snapshot at a specific block or the latest available.

```
StateSnapshotQuery extends BlockNodeQuery<StateSnapshot> {
    // Set the last block number to include in the snapshot (optional)
    // If retrieveLatest is true, this field is ignored
    StateSnapshotQuery setLastBlockNumber(blockNumber: uint64)

    // Get the last block number
    @@nullable uint64 getLastBlockNumber()

    // Set whether to retrieve the latest available snapshot (optional, default false)
    // Some Block Nodes may require this to be true (check onlyLatestState in BlockNodeInfo)
    StateSnapshotQuery setRetrieveLatest(retrieveLatest: bool)

    // Get whether to retrieve the latest snapshot
    bool getRetrieveLatest()
}
```

Note: `execute()` may throw `state-not-available-error` in addition to the base `block-node-error`.

#### BlockContentsProofQuery

Request a cryptographic proof for a specific item in a block. Exactly one of `blockItem`, `blockItemHash`, or `blockItemIndex` must be set.

```
BlockContentsProofQuery extends BlockNodeQuery<BlockContentsProof> {
    // Set the block number containing the item (required)
    BlockContentsProofQuery setBlockNumber(blockNumber: uint64)

    // Get the block number
    uint64 getBlockNumber()

    // Set the complete block item to generate proof for (use this OR hash OR index)
    BlockContentsProofQuery setBlockItem(blockItem: BlockItem)

    // Get the block item
    @@nullable BlockItem getBlockItem()

    // Set the item hash (use this OR blockItem OR index)
    // Use when the block item is identified by its hash and there is only one match
    BlockContentsProofQuery setBlockItemHash(itemHash: bytes)

    // Get the item hash
    @@nullable bytes getBlockItemHash()

    // Set the item index within the block (use this OR blockItem OR hash)
    // Use when there are multiple items with the same hash
    BlockContentsProofQuery setBlockItemIndex(itemIndex: uint32)

    // Get the item index
    @@nullable uint32 getBlockItemIndex()
}
```

Note: `execute()` may throw `proof-not-available-error`, `item-not-found-error`, or `duplicate-hash-error` in addition to the base `block-node-error`.

#### StateProofQuery

Request a cryptographic proof for a state value at a specific block.

```
StateProofQuery extends BlockNodeQuery<StateProof> {
    // Set the block number at which to prove the state (required)
    StateProofQuery setBlockNumber(blockNumber: uint64)

    // Get the block number
    uint64 getBlockNumber()

    // Set the state key to prove (required)
    StateProofQuery setStateKey(stateKey: bytes)

    // Get the state key
    bytes getStateKey()
}
```

Note: `execute()` may throw `proof-not-available-error` or `key-not-found-error` in addition to the base `block-node-error`.

---

## Updated APIs

### Client

The existing `Client` class is extended with Block Node network management, following the same pattern used for Mirror Network configuration.

```
Client {
    // Get the Block Node network addresses
    list<string> getBlockNodeNetwork()

    // Set the Block Node network addresses
    Client setBlockNodeNetwork(addresses: list<string>)

    // Update the Block Node network from a Block Node address book
    Client setBlockNodeNetworkFromAddressBook(addressBook: BlockNodeAddressBook)

    // Create a client bootstrapped from Block Node network only
    // Useful when only Block Node access is needed (no transaction submission)
    @@static
    @@async
    Client forBlockNodeNetwork(addresses: list<string>)
}
```

---

## Internal Changes

### Abstract Query Implementation

The `BlockNodeQuery` abstraction provides:

1. **Common Configuration**: gRPC deadline settings inherited by all request/response queries
2. **Execution Logic**: Connection to Block Node network, retry handling, error mapping
3. **Type Safety**: Generic response types ensure compile-time type checking

SDKs should implement this abstraction following their language's idiomatic patterns for generic abstract types.

Note: `BlockStreamQuery` is a standalone class (not extending `BlockNodeQuery`) since streaming queries have different execution patterns (`subscribe()` vs `execute()`). If additional streaming query types are needed in the future, a common abstraction can be introduced at that time.

### Block Node Network Management

The SDK manages Block Node connections similarly to how it manages Mirror Network connections:

1. **Connection Management**: Internal component managing gRPC channels to Block Nodes.

2. **Connection Pooling**: Block Node connections are pooled and load-balanced across configured endpoints.

3. **Health Tracking**: Failed Block Node connections are tracked and temporarily removed from the pool, similar to consensus node health tracking.

4. **Channel Reuse**: Reuse existing gRPC channel infrastructure and TLS configuration patterns from the SDK.

### Query Execution

Block Node queries follow the existing `MirrorQuery` pattern:

1. Queries execute against the client's Block Node network
2. If no Block Node network is configured, queries throw a descriptive error
3. Retry logic follows the same exponential backoff pattern as other queries
4. Streaming queries (`BlockStreamQuery`) use `AsyncSequence` like `TopicMessageQuery`

### Error Handling

Block Node errors are surfaced using each SDK's existing error pattern. The following error cases should be added:

| Error | Description |
|-------|-------------|
| `blockNodeNetworkNotConfigured` | Block Node query attempted without configuring Block Node network |
| `blockNodeGrpcStatus` | gRPC error from Block Node (includes status code) |
| `blockNotFound` | Requested block does not exist |
| `blockNotAvailable` | Requested block exists but is not available on this node |
| `stateNotAvailable` | State snapshot not available for the requested block |
| `proofNotAvailable` | Proof generation not available for the requested block |
| `blockItemNotFound` | Specified block item was not found |
| `stateKeyNotFound` | Specified state key was not found |
| `duplicateHashItem` | Multiple items match the provided hash |
| `invalidBlockRange` | Invalid block range (e.g., end before start) |

### Response Codes

The following response codes may be returned by Block Node services:

**Subscribe Stream Response Codes:**
- `UNKNOWN` - Server software failed to set a status
- `SUCCESS` - Request succeeded
- `INVALID_REQUEST` - Malformed or structurally incorrect request
- `ERROR` - Block Node encountered an error
- `INVALID_START_BLOCK_NUMBER` - Requested start block is not valid
- `INVALID_END_BLOCK_NUMBER` - Requested end block is not valid
- `NOT_AVAILABLE` - Requested stream is not available

**Block Access Response Codes:**
- `UNKNOWN` - Server software failed to set a status
- `SUCCESS` - Request succeeded
- `INVALID_REQUEST` - Malformed request
- `ERROR` - Block Node encountered an error
- `NOT_FOUND` - Block does not exist
- `NOT_AVAILABLE` - Block not currently available on this node

**State Snapshot Response Codes:**
- `UNKNOWN` - Server software failed to set a status
- `SUCCESS` - Request succeeded
- `INVALID_REQUEST` - Malformed request
- `ERROR` - Block Node encountered an error

**Block Contents Proof Response Codes:**
- `UNKNOWN` - Server software failed to set a status
- `SUCCESS` - Request succeeded
- `INVALID_REQUEST` - Malformed request
- `ERROR` - Block Node encountered an error
- `ITEM_NOT_FOUND` - Specified block item was not found
- `NOT_AVAILABLE` - Proof not available for specified block
- `DUPLICATE_HASH_ITEM_FOUND` - Duplicate hash items found, use item index instead

**State Proof Response Codes:**
- `UNKNOWN` - Server software failed to set a status
- `SUCCESS` - Request succeeded
- `KEY_NOT_FOUND` - Specified state key was not found
- `NOT_AVAILABLE` - State proof not available for specified block

#### Transaction Retry

Block Node APIs do not directly involve transaction submission. However, SDKs should implement retry logic for:
- `INTERNAL_ERROR` - Retry with exponential backoff
- `NOT_AVAILABLE` - Retry after short delay or rotate to another Block Node
- gRPC `UNAVAILABLE`, `RESOURCE_EXHAUSTED` - Retry with exponential backoff

---

## Test Plan

### Client Block Node Configuration

1. **Given** a `Client` instance, **when** `setBlockNodeNetwork()` is called with valid addresses, **then** the Block Node network is configured and subsequent Block Node queries succeed.

2. **Given** a `Client` instance with no Block Node network configured, **when** a Block Node query is executed, **then** an error indicating "Block Node network not configured" is thrown.

3. **Given** valid Block Node addresses, **when** `Client.forBlockNodeNetwork()` is called, **then** a client is created with only Block Node connectivity (no consensus/mirror networks).

4. **Given** a `Client` with Block Node network configured, **when** `blockNodeNetwork` property is accessed, **then** the configured addresses are returned.

### ServerStatusQuery

5. **Given** a `Client` with Block Node network configured, **when** `ServerStatusQuery().execute(client)` is called, **then** a `BlockNodeInfo` is returned containing `firstAvailableBlock`, `lastAvailableBlock`, `onlyLatestState`, and `versionInformation`.

6. **Given** a `Client` connected to an unreachable Block Node, **when** `ServerStatusQuery().execute(client)` is called, **then** an error is thrown after retry attempts are exhausted.

### BlockQuery

7. **Given** a valid block number within the node's available range, **when** `BlockQuery().setBlockNumber(n).execute(client)` is called, **then** a `Block` is returned with header, items, and proof.

8. **Given** a block number that does not exist, **when** `BlockQuery().setBlockNumber(n).execute(client)` is called, **then** a `block-not-found-error` is thrown.

9. **Given** a block number outside the node's available range, **when** `BlockQuery().setBlockNumber(n).execute(client)` is called, **then** a `block-not-available-error` is thrown.

10. **Given** a `Block` returned from a query, **when** `itemsByType(.transactionResult)` is called, **then** only transaction result items are returned.

11. **Given** a `BlockQuery`, **when** `setRetrieveLatest(true).execute(client)` is called, **then** the latest available block is returned.

### BlockStreamQuery

12. **Given** a valid start block number, **when** `BlockStreamQuery().setStartBlockNumber(n).subscribe(client)` is called, **then** an async sequence is returned that yields blocks starting from block n.

13. **Given** an active block stream subscription, **when** iterating with `for await block in stream`, **then** blocks are received in order.

14. **Given** a block stream with start and end block numbers, **when** the end block is reached, **then** the async sequence completes normally.

15. **Given** a block stream subscription with no end block, **when** new blocks are produced, **then** they are received in the stream until cancelled.

16. **Given** an invalid start block number (greater than available), **when** `BlockStreamQuery().setStartBlockNumber(n).subscribe(client)` is called, **then** an error with `INVALID_START_BLOCK_NUMBER` is thrown.

17. **Given** an end block less than start block, **when** `BlockStreamQuery().setStartBlockNumber(10).setEndBlockNumber(5).subscribe(client)` is called, **then** an error with `INVALID_END_BLOCK_NUMBER` is thrown.

18. **Given** a start and end block number, **when** `BlockStreamQuery().setStartBlockNumber(n).setEndBlockNumber(m).execute(client)` is called, **then** all blocks in the range are collected and returned as a list.

### StateSnapshotQuery

19. **Given** a Block Node that supports state snapshots, **when** `StateSnapshotQuery().setRetrieveLatest(true).execute(client)` is called, **then** the latest `StateSnapshot` is returned.

20. **Given** a Block Node that supports state snapshots and a valid block number, **when** `StateSnapshotQuery().setLastBlockNumber(n).execute(client)` is called, **then** a `StateSnapshot` for that block is returned.

21. **Given** a Block Node with `onlyLatestState=true`, **when** `StateSnapshotQuery().setLastBlockNumber(n).execute(client)` is called (without `retrieveLatest=true`), **then** an error is thrown.

22. **Given** a block number that has no snapshot, **when** `StateSnapshotQuery().setLastBlockNumber(n).execute(client)` is called, **then** an error is thrown.

### BlockContentsProofQuery

23. **Given** a valid block number and item index, **when** `BlockContentsProofQuery().setBlockNumber(n).setBlockItemIndex(i).execute(client)` is called, **then** a `BlockContentsProof` is returned.

24. **Given** an invalid item index, **when** `BlockContentsProofQuery().setBlockNumber(n).setBlockItemIndex(999).execute(client)` is called, **then** an `item-not-found-error` is thrown.

25. **Given** a valid item hash, **when** `BlockContentsProofQuery().setBlockNumber(n).setBlockItemHash(hash).execute(client)` is called, **then** a `BlockContentsProof` is returned.

26. **Given** a hash matching multiple items, **when** `BlockContentsProofQuery().setBlockNumber(n).setBlockItemHash(hash).execute(client)` is called, **then** a `duplicate-hash-error` is thrown (client should use `setBlockItemIndex` instead).

27. **Given** a Block Node that does not support proofs, **when** `BlockContentsProofQuery().setBlockNumber(n).setBlockItemIndex(i).execute(client)` is called, **then** a `proof-not-available-error` is thrown.

### StateProofQuery

28. **Given** a valid block number and state key, **when** `StateProofQuery().setBlockNumber(n).setStateKey(key).execute(client)` is called, **then** a `StateProof` is returned.

29. **Given** a non-existent state key, **when** `StateProofQuery().setBlockNumber(n).setStateKey(key).execute(client)` is called, **then** a `key-not-found-error` is thrown.

30. **Given** a block that doesn't support state proofs, **when** `StateProofQuery().setBlockNumber(n).setStateKey(key).execute(client)` is called, **then** a `proof-not-available-error` is thrown.

### Error Handling and Resilience

31. **Given** a `Client` experiencing transient Block Node connection errors, **when** any Block Node query is executed, **then** the SDK retries with exponential backoff before failing.

32. **Given** a block stream subscription that loses connection, **when** reconnection succeeds, **then** streaming resumes from the last received block number.

33. **Given** a `Client` with multiple Block Node addresses configured, **when** one Block Node becomes unhealthy, **then** queries are routed to healthy Block Nodes.

### TCK

The tests defined above should be implemented in the [TCK repository](https://github.com/hiero-ledger/hiero-sdk-tck). Issues should be created to track:
- Client Block Node configuration tests
- Block access and retrieval tests
- Block stream subscription tests
- State snapshot query tests
- Proof generation and verification tests
- Error handling and resilience tests

---

## SDK Example

### Subscribing to Real-Time Block Stream

This example demonstrates how to connect to a Block Node and subscribe to a live block stream, following patterns established by `TopicMessageQuery`:

1. Create a client and configure the operator
2. Configure the Block Node network addresses
3. Query Block Node status to understand available data
4. Subscribe to the block stream starting from the latest block
5. Process blocks as they arrive in the async stream

### Using Block Nodes Alongside Consensus Operations

This example shows how Block Node queries work alongside regular transaction submission:

1. Create a fully configured client with operator and Block Node network
2. Submit a transaction via Consensus Network
3. Wait for block to be available
4. Query recent blocks from Block Node

### Retrieving Historical Blocks

This example shows how to retrieve specific historical blocks:

1. Create a client with only Block Node access (no operator needed for read-only operations)
2. Get a specific block by number
3. Examine the block header and proof
4. Get a range of blocks

### Obtaining Cryptographic Proofs

This example demonstrates requesting proofs for verification:

1. Create a client with Block Node access
2. Get a block contents proof for a specific item
3. Get a state proof for a specific key at a block

### Querying State Snapshots

This example shows how to obtain state snapshot references:

1. Create a client with Block Node access
2. Check if the Block Node only supports the latest state snapshot (via `onlyLatestState`)
3. Get the latest state snapshot using `setRetrieveLatest(true)`
4. If supported, get a state snapshot at a specific block using `setLastBlockNumber(n)`

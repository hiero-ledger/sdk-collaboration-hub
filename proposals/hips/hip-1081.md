# HIP-1081: Block Node SDK Integration

## Table of Contents

- [Summary](#summary)
  - [Type-to-Proto Reference](#type-to-proto-reference)
- [New APIs](#new-apis)
  - [Namespace Overview](#namespace-overview)
  - [Implementation Reference](#implementation-reference)
  - [namespace blockNode](#namespace-blocknode)
  - [namespace blockStream](#namespace-blockstream)
  - [namespace stateChanges](#namespace-statechanges)
  - [namespace state](#namespace-state)
    - [Network Configuration State](#network-configuration-state)
    - [Network Entity State Types](#network-entity-state-types)
    - [Platform & Consensus State Types](#platform--consensus-state-types)
    - [Contract & Hook State Types](#contract--hook-state-types)
    - [Schedule State Types](#schedule-state-types)
    - [TSS State Types](#tss-state-types)
    - [hinTS State Types](#hints-state-types)
    - [History Proof State Types](#history-proof-state-types)
  - [namespace proofs](#namespace-proofs)
  - [namespace legacy](#namespace-legacy)
- [Updated APIs](#updated-apis)
- [Internal Changes](#internal-changes)
  - [SubscribeStreamResponseCode](#subscribestreamresponsecode)
  - [Query Implementation](#query-implementation)
  - [Block Stream Subscription Behavior](#block-stream-subscription-behavior)
  - [Block Node Network Management](#block-node-network-management)
  - [Query Execution](#query-execution)
  - [Error Handling](#error-handling)
  - [Response Codes](#response-codes)
- [Test Plan](#test-plan)
- [SDK Example](#sdk-example)

---

## Summary

HIP-1081 introduces Block Nodes as a decentralized data layer for the Hiero network. Block Nodes receive block streams from Consensus Nodes, verify block integrity, store the blockchain, and distribute blocks to downstream clients such as Mirror Nodes, dApps, and other Block Nodes.

This design document defines the SDK APIs required for applications to interact with Block Nodes. The SDK enables developers to:
- Subscribe to real-time and historical block streams
- Query Block Node status and capabilities
- Retrieve specific blocks by number
Block Node connectivity is integrated into the existing `Client` class, following the established pattern where the `Client` manages connections to multiple network components (Consensus Nodes, Mirror Nodes, and now Block Nodes). This provides a consistent, unified experience for SDK users. For usage examples demonstrating these capabilities, see [SDK Example](#sdk-example).

**HIP:** https://hips.hedera.com/hip/hip-1081

**Related HIPs:**
- [HIP-1056: Block Streams](https://hips.hedera.com/hip/hip-1056)
- [HIP-1137: Block Node Discoverability](https://github.com/hiero-ledger/hiero-improvement-proposals/pull/1137)
- [HIP-1183: The hinTS threshold signature scheme](https://github.com/hiero-ledger/hiero-improvement-proposals/pull/1200)

**Date Submitted:** 2025-01-07

**Protobuf definitions:** The Block Node gRPC services and message types are defined formally in the [hiero-block-node](https://github.com/hiero-ledger/hiero-block-node) repository (`protobuf-sources/src/main/proto/block-node/api/`). SDK APIs in this document align with those definitions.

**Scope:** The Block Node protobufs define additional gRPC services beyond those covered here. This document covers the initial set of SDK APIs: **BlockNodeService** (`serverStatus`), **BlockAccessService** (`getBlock`), and **BlockStreamSubscribeService** (`subscribeBlockStream`). The following services are **deferred to a future design document**:
- **ProofService** (`getBlockContentsProof`, `getStateProof`) — requesting cryptographic proofs for specific block items or state entries
- **StateService** (`stateSnapshot`) — retrieving state snapshot references
- **BlockStreamPublishService** (`publishBlockStream`) — publishing blocks (consensus-node-to-block-node; not an SDK consumer API)
- **ReconnectService** (`reconnect`) — block-node-to-block-node reconnection (not an SDK consumer API)

**Wrapper types:** SDKs must not expose proto-generated or wire-format types in the public API. All types defined in this document (and any block stream or Block Node data exposed to the application) must be exposed as **wrapper types**: language-native types with the shapes and semantics specified here. SDKs implement these wrappers over the underlying proto or gRPC layer; the public API is stable and implementation-agnostic.

**Forward compatibility — unknown enum values:** SDKs MUST handle unknown/unrecognized enum values gracefully for ALL block stream and Block Node enums defined in this document. When an enum value is encountered that is not defined in the SDK's current version, the SDK MUST map it to an unknown/default variant (e.g. `UNKNOWN`, `ITEM_TYPE_UNSPECIFIED`, or a language-idiomatic equivalent) rather than failing deserialization. This ensures that blocks produced by newer consensus node versions can still be processed by SDKs that have not yet been updated.

**Referenced types not defined in this document:**
- **Already in SDKs (use existing wrapper):** **Status** (or ResponseCode in Python), **Transfer** (wraps proto `AccountAmount`; some SDKs name this `HbarTransfer` — see [SDK-Specific Naming](#sdk-specific-naming)), **TokenTransferList**, **TokenAssociation** (missing in Python; must be added), **AssessedCustomFee**, **ExchangeRates** (wraps proto `ExchangeRateSet`; present in Java/JS/C++/Swift/Rust as `ExchangeRates`, Go as `ExchangeRate`, missing in Python; must be added — see [SDK-Specific Naming](#sdk-specific-naming)), **ExchangeRate**, **ScheduleId**, **TransactionId**, **AccountId**, **ContractId**, **FileId**, **TokenId**, **TopicId**, **NftId**, **PendingAirdropId**, **Transaction**, **TransactionRecord**, **Client**, **SubscriptionHandle**, **SemanticVersion**, **Key**, **KeyList**, **ServiceEndpoint**, **TokenType**, **TokenSupplyType**. All other types referenced in this document are defined below or in the block stream protos (wrapper shapes given in this doc).
- **Defined in [HIP-1195](hips/hip-1195.md) (use that document's definitions):** **HookId**, **HookEntityId**, **HookExtensionPoint**.
- **New types defined in this document:** **EvmTransactionResult** (wrapping `proto.EvmTransactionResult` from `services/contract_types.proto`) is a new type, distinct from the existing SDK `ContractFunctionResult` (which wraps the legacy `proto.ContractFunctionResult`). Both are defined in the same proto file but have different fields and purposes.

### Type-to-Proto Reference

The following table provides a reference mapping from the SDK wrapper types defined in this document to their corresponding protobuf definitions. See also [Implementation Reference](#implementation-reference) under New APIs for SDK-specific naming conventions and prerequisites.

| SDK Type | Proto File | Proto Message |
|---|---|---|
| **Block Node API** | | |
| `BlockAccessResponseCode` | `block-node/api/block_access_service.proto` | `BlockResponse.Code` |
| `BlockNodeVersions` | `block-node/api/node_service.proto` | `BlockNodeVersions` |
| `ServerStatus` | `block-node/api/node_service.proto` | `ServerStatusResponse` |
| `BlockResult` | `block-node/api/block_access_service.proto` | `BlockResponse` |
| **Block Stream** | | |
| `Block` | `block/stream/block.proto` | `Block` |
| `BlockItem` | `block/stream/block_item.proto` | `BlockItem` |
| `BlockItemType` | `block/stream/block_item.proto` | `BlockItem.item` (oneof) |
| `BlockHeader` | `block/stream/output/block_header.proto` | `BlockHeader` |
| `BlockHashAlgorithm` | `services/basic_types.proto` | `BlockHashAlgorithm` |
| `EventCore` | `platform/event/event_core.proto` | `EventCore` |
| `EventDescriptor` | `platform/event/event_descriptor.proto` | `EventDescriptor` |
| `ParentEventReference` | `block/stream/input/event_metadata.proto` | `ParentEventReference` |
| `EventHeader` | `block/stream/input/event_metadata.proto` | `EventHeader` |
| `RoundHeader` | `block/stream/input/round_header.proto` | `RoundHeader` |
| `TransactionResult` | `block/stream/output/transaction_result.proto` | `TransactionResult` |
| `TransactionOutput` | `block/stream/output/transaction_output.proto` | `TransactionOutput` |
| `UtilPrngOutput` | `block/stream/output/util_service.proto` | `UtilPrngOutput` |
| `EvmTransactionResult` | `services/contract_types.proto` | `EvmTransactionResult` |
| `InternalCallContext` | `services/contract_types.proto` | `InternalCallContext` |
| `ContractNonceInfo` | `services/contract_types.proto` | `ContractNonceInfo` |
| `CallContractOutput` | `block/stream/output/smart_contract_service.proto` | `CallContractOutput` |
| `CreateContractOutput` | `block/stream/output/smart_contract_service.proto` | `CreateContractOutput` |
| `EthereumOutput` | `block/stream/output/smart_contract_service.proto` | `EthereumOutput` |
| `CreateScheduleOutput` | `block/stream/output/schedule_service.proto` | `CreateScheduleOutput` |
| `SignScheduleOutput` | `block/stream/output/schedule_service.proto` | `SignScheduleOutput` |
| `CreateAccountOutput` | `block/stream/output/crypto_service.proto` | `CreateAccountOutput` |
| `SubMerkleTree` | `block/stream/block_item.proto` | `SubMerkleTree` |
| `FilteredSingleItem` | `block/stream/block_item.proto` | `FilteredSingleItem` |
| `RedactedItem` | `block/stream/block_item.proto` | `RedactedItem` |
| `BlockFooter` | `block/stream/output/block_footer.proto` | `BlockFooter` |
| **Trace Data** | | |
| `TraceData` | `block/stream/trace/trace_data.proto` | `TraceData` |
| `EvmTraceData` | `block/stream/trace/smart_contract_service.proto` | `EvmTraceData` |
| `ContractAction` | `streams/contract_action.proto` | `ContractAction` |
| `ContractActionType` | `streams/contract_action.proto` | `ContractActionType` |
| `CallOperationType` | `streams/contract_action.proto` | `CallOperationType` |
| `ContractSlotUsage` | `block/stream/trace/smart_contract_service.proto` | `ContractSlotUsage` |
| `WrittenSlotKeys` | `block/stream/trace/smart_contract_service.proto` | `WrittenSlotKeys` |
| `SlotRead` | `block/stream/trace/smart_contract_service.proto` | `SlotRead` |
| `ExecutedInitcode` | `block/stream/trace/smart_contract_service.proto` | `ExecutedInitcode` |
| `InitcodeBookends` | `block/stream/trace/smart_contract_service.proto` | `InitcodeBookends` |
| `EvmTransactionLog` | `block/stream/trace/smart_contract_service.proto` | `EvmTransactionLog` |
| `SubmitMessageTraceData` | `block/stream/trace/consensus_service.proto` | `SubmitMessageTraceData` |
| **State Changes** | | |
| `StateChanges` | `block/stream/output/state_changes.proto` | `StateChanges` |
| `StateChange` | `block/stream/output/state_changes.proto` | `StateChange` |
| `StateIdentifier` | `block/stream/output/state_changes.proto` | `StateIdentifier` |
| `NewStateChange` | `block/stream/output/state_changes.proto` | `NewStateChange` |
| `NewStateType` | `block/stream/output/state_changes.proto` | `NewStateType` |
| `RemovedStateChange` | `block/stream/output/state_changes.proto` | `RemovedStateChange` |
| `SingletonUpdateChange` | `block/stream/output/state_changes.proto` | `SingletonUpdateChange` |
| `MapChangeKey` | `block/stream/output/state_changes.proto` | `MapChangeKey` |
| `MapChangeValue` | `block/stream/output/state_changes.proto` | `MapChangeValue` |
| `MapUpdateChange` | `block/stream/output/state_changes.proto` | `MapUpdateChange` |
| `MapDeleteChange` | `block/stream/output/state_changes.proto` | `MapDeleteChange` |
| `QueuePushChange` | `block/stream/output/state_changes.proto` | `QueuePushChange` |
| `QueuePopChange` | `block/stream/output/state_changes.proto` | `QueuePopChange` |
| `TransactionReceiptEntry` | `services/state/recordcache/recordcache.proto` | `TransactionReceiptEntry` |
| `TransactionReceiptEntries` | `services/state/recordcache/recordcache.proto` | `TransactionReceiptEntries` |
| **Network Configuration State** | | |
| `BlockInfo` | `services/state/blockrecords/block_info.proto` | `BlockInfo` |
| `CongestionLevelStarts` | `services/state/congestion/congestion_level_starts.proto` | `CongestionLevelStarts` |
| `NetworkStakingRewards` | `services/state/token/network_staking_rewards.proto` | `NetworkStakingRewards` |
| `NodeRewards` | `services/state/token/node_rewards.proto` | `NodeRewards` |
| `NodeActivity` | `services/state/token/node_rewards.proto` | `NodeActivity` |
| `NodePayments` | `services/state/token/node_payments.proto` | `NodePayments` |
| `NodePayment` | `services/state/token/node_payments.proto` | `NodePayment` |
| `RunningHashes` | `services/state/blockrecords/running_hashes.proto` | `RunningHashes` |
| `ThrottleUsageSnapshots` | `services/state/throttles/throttle_usage_snapshots.proto` | `ThrottleUsageSnapshots` |
| `ThrottleUsageSnapshot` | `services/state/throttles/throttle_usage_snapshots.proto` | `ThrottleUsageSnapshot` |
| `BlockStreamInfo` | `services/state/blockstream/block_stream_info.proto` | `BlockStreamInfo` |
| `EntityCounts` | `services/state/entity/entity_counts.proto` | `EntityCounts` |
| **Network Entity State** | | |
| `Account` | `services/state/token/account.proto` | `Account` |
| `Bytecode` | `services/state/contract/bytecode.proto` | `Bytecode` |
| `File` | `services/state/file/file.proto` | `File` |
| `Nft` | `services/state/token/nft.proto` | `Nft` |
| `Schedule` | `services/state/schedule/schedule.proto` | `Schedule` |
| `ScheduleList` | `services/state/schedule/schedule.proto` | `ScheduleList` |
| `ScheduledCounts` | `services/state/schedule/schedule.proto` | `ScheduledCounts` |
| `Token` | `services/state/token/token.proto` | `Token` |
| `TokenRelation` | `services/state/token/token_relation.proto` | `TokenRelation` |
| `Topic` | `services/state/consensus/topic.proto` | `Topic` |
| `Node` | `services/state/addressbook/node.proto` | `Node` |
| `StakingNodeInfo` | `services/state/token/staking_node_info.proto` | `StakingNodeInfo` |
| `AccountPendingAirdrop` | `services/state/token/account_pending_airdrop.proto` | `AccountPendingAirdrop` |
| **Platform & Consensus State** | | |
| `PlatformState` | `platform/state/platform_state.proto` | `PlatformState` |
| `ConsensusSnapshot` | `platform/state/platform_state.proto` | `ConsensusSnapshot` |
| `MinimumJudgeInfo` | `platform/state/platform_state.proto` | `MinimumJudgeInfo` |
| `JudgeId` | `platform/state/platform_state.proto` | `JudgeId` |
| `Roster` | `services/state/roster/roster.proto` | `Roster` |
| `RosterEntry` | `services/state/roster/roster.proto` | `RosterEntry` |
| `RosterState` | `services/state/roster/roster_state.proto` | `RosterState` |
| **Contract & Hook State** | | |
| `SlotKey` | `services/state/contract/storage_slot.proto` | `SlotKey` |
| `SlotValue` | `services/state/contract/storage_slot.proto` | `SlotValue` |
| `EvmHookState` | `services/state/contract/evm_hook_state.proto` | `EvmHookState` |
| `EvmHookSlotKey` | `services/state/contract/evm_hook_state.proto` | `EvmHookSlotKey` |
| **Schedule State** | | |
| `ScheduledOrder` | `services/state/schedule/schedule.proto` | `ScheduledOrder` |
| `TimestampSeconds` | `services/timestamp.proto` | `TimestampSeconds` |
| **TSS State** | | |
| `TssMessageMapKey` | `services/state/tss/tss_message_map_key.proto` | `TssMessageMapKey` |
| `TssVoteMapKey` | `services/state/tss/tss_vote_map_key.proto` | `TssVoteMapKey` |
| `TssEncryptionKeys` | `services/state/tss/tss_encryption_keys.proto` | `TssEncryptionKeys` |
| `TssMessageTransactionBody` | `services/auxiliary/tss/tss_message.proto` | `TssMessageTransactionBody` |
| `TssVoteTransactionBody` | `services/auxiliary/tss/tss_vote.proto` | `TssVoteTransactionBody` |
| **hinTS State** | | |
| `HintsPartyId` | `services/state/hints/hints_types.proto` | `HintsPartyId` |
| `PreprocessingVoteId` | `services/state/hints/hints_types.proto` | `PreprocessingVoteId` |
| `HintsKeySet` | `services/state/hints/hints_types.proto` | `HintsKeySet` |
| `PreprocessedKeys` | `services/state/hints/hints_types.proto` | `PreprocessedKeys` |
| `NodePartyId` | `services/state/hints/hints_types.proto` | `NodePartyId` |
| `HintsScheme` | `services/state/hints/hints_types.proto` | `HintsScheme` |
| `PreprocessingVote` | `services/state/hints/hints_types.proto` | `PreprocessingVote` |
| `HintsConstruction` | `services/state/hints/hints_types.proto` | `HintsConstruction` |
| `CRSStage` | `services/state/hints/hints_types.proto` | `CRSStage` |
| `CRSState` | `services/state/hints/hints_types.proto` | `CRSState` |
| `CrsPublicationTransactionBody` | `services/auxiliary/hints/crs_publication.proto` | `CrsPublicationTransactionBody` |
| **History Proof State** | | |
| `ConstructionNodeId` | `services/state/history/history_types.proto` | `ConstructionNodeId` |
| `ProofKeySet` | `services/state/history/history_types.proto` | `ProofKeySet` |
| `ProofKey` | `services/state/history/history_types.proto` | `ProofKey` |
| `History` | `services/state/history/history_types.proto` | `History` |
| `HistoryProof` | `services/state/history/history_types.proto` | `HistoryProof` |
| `HistorySignature` | `services/state/history/history_types.proto` | `HistorySignature` |
| `RecordedHistorySignature` | `services/state/history/history_types.proto` | `RecordedHistorySignature` |
| `HistoryProofVote` | `services/state/history/history_types.proto` | `HistoryProofVote` |
| `WrapsPhase` | `services/state/history/history_types.proto` | `WrapsPhase` |
| `WrapsSigningState` | `services/state/history/history_types.proto` | `WrapsSigningState` |
| `HistoryProofConstruction` | `services/state/history/history_types.proto` | `HistoryProofConstruction` |
| `WrapsMessageDetails` | `services/state/history/history_types.proto` | `WrapsMessageDetails` |
| `WrapsMessageHistory` | `services/state/history/history_types.proto` | `WrapsMessageHistory` |
| **Proofs** | | |
| `BlockProof` | `block/stream/block_proof.proto` | `BlockProof` |
| `StateProof` | `block/stream/state_proof.proto` | `StateProof` |
| `MerklePath` | `block/stream/state_proof.proto` | `MerklePath` |
| `MerkleLeaf` | `services/state/blockstream/merkle_leaf.proto` | `MerkleLeaf` |
| `SiblingNode` | `block/stream/state_proof.proto` | `SiblingNode` |
| `TssSignedBlockProof` | `block/stream/state_proof.proto` | `TssSignedBlockProof` |
| `SignedRecordFileProof` | `block/stream/block_proof.proto` | `SignedRecordFileProof` |
| `RecordFileSignature` | `block/stream/block_proof.proto` | `RecordFileSignature` |
| `AggregatedNodeSignatures` | `block/stream/chain_of_trust_proof.proto` | `AggregatedNodeSignatures` |
| `ChainOfTrustProof` | `block/stream/chain_of_trust_proof.proto` | `ChainOfTrustProof` |
| **Legacy (Record Stream)** | | |
| `RecordFileItem` | `block/stream/record_file_item.proto` | `RecordFileItem` |
| `RecordStreamFile` | `streams/record_stream_file.proto` | `RecordStreamFile` |
| `RecordStreamItem` | `streams/record_stream_file.proto` | `RecordStreamItem` |
| `SidecarFile` | `streams/sidecar_file.proto` | `SidecarFile` |
| `TransactionSidecarRecord` | `streams/sidecar_file.proto` | `TransactionSidecarRecord` |
| `SidecarType` | `streams/sidecar_file.proto` | `SidecarType` |
| `SidecarMetadata` | `streams/record_stream_file.proto` | `SidecarMetadata` |
| `ContractStateChanges` | `streams/contract_state_change.proto` | `ContractStateChanges` |
| `ContractStateChange` | `streams/contract_state_change.proto` | `ContractStateChange` |
| `StorageChange` | `streams/contract_state_change.proto` | `StorageChange` |
| `ContractActions` | `streams/contract_action.proto` | `ContractActions` |
| `ContractBytecode` | `streams/contract_bytecode.proto` | `ContractBytecode` |
| `HashObject` | `streams/hash_object.proto` | `HashObject` |
| `HashAlgorithm` | `streams/hash_object.proto` | `HashAlgorithm` |

---

## New APIs

### Namespace Overview

The new APIs are organized into six namespaces:

| Namespace | Purpose |
|---|---|
| [**blockNode**](#namespace-blocknode) | Client-facing API: queries, responses, configuration, and enums for Block Node interaction |
| [**blockStream**](#namespace-blockstream) | Block stream data model: blocks, block items, headers, transaction results/outputs, and trace data |
| [**stateChanges**](#namespace-statechanges) | State change infrastructure: containers, keys, values, and change operations for network state mutations |
| [**state**](#namespace-state) | Network state types: entity state, platform/consensus state, configuration singletons, and protocol-internal state |
| [**proofs**](#namespace-proofs) | Cryptographic proof types: merkle trees, signatures, and proof containers |
| [**legacy**](#namespace-legacy) | Legacy record stream types (pre-block stream format) |

Namespace dependencies: `blockStream` requires `blockNode`, `state`, `proofs`, `legacy`. `stateChanges` requires `blockStream`, `state`. `proofs` requires `blockStream`, `state`. `legacy` requires `blockStream`.

### Implementation Reference

#### SDK-Specific Naming

Some existing SDK types have names that differ from the canonical names used in this document. SDKs must preserve their existing naming conventions for these types:

| Canonical Name (this doc) | Java | JS | Go | C++ | Swift | Rust | Python |
|---|---|---|---|---|---|---|---|
| `Status` | `Status` | `Status` | `Status` | `Status` | `Status` | `Status` | `ResponseCode` |
| `Transfer` | `Transfer` | `Transfer` | `Transfer` | `HbarTransfer` | `Transfer` | `Transfer` | `HbarTransfer` |
| `ExchangeRates` | `ExchangeRates` | `ExchangeRates` | `ExchangeRate` | `ExchangeRates` | `ExchangeRates` | `ExchangeRates` | **must add** |
| `TokenAssociation` | `TokenAssociation` | `TokenAssociation` | `TokenAssociation` | `TokenAssociation` | `TokenAssociation` | `TokenAssociation` | **must add** |

#### SDK Prerequisites

Before implementing Block Node APIs, the following gaps in individual SDKs must be addressed:

| SDK | Missing Types / Prerequisites |
|---|---|
| Python | Add `ExchangeRates` wrapper (wrapping proto `ExchangeRateSet`); add `TokenAssociation` wrapper |
| Go | No missing types. Note: Go uses `ExchangeRate` (singular) for the `ExchangeRateSet` wrapper |
| Java, JS, C++, Swift, Rust | No missing types |

---

### namespace blockNode

Types for Block Node API interaction: queries, responses, configuration, and enums. Error identifiers used in `@@throws` annotations are defined in [Error Handling](#error-handling).

#### BlockAccessResponseCode

Response codes returned when accessing a single block.

```
enum BlockAccessResponseCode {
    UNKNOWN
    SUCCESS
    INVALID_REQUEST
    ERROR
    NOT_FOUND
    NOT_AVAILABLE
}
```

#### BlockNodeVersions

Version information for a Block Node.

```
@@finalType
BlockNodeVersions {
    // A version of the Block Node network address book
    @@immutable addressBookVersion: SemanticVersion

    // A version of the Block Stream specification supported by this Block Node
    @@immutable streamProtoVersion: SemanticVersion

    // A version of the Block Node software
    @@immutable softwareVersion: SemanticVersion
}
```

#### ServerStatus

Information about a Block Node's status and capabilities. Returned by **ServerStatusQuery**; corresponds to the `ServerStatusResponse` from the Block Node `serverStatus` RPC.

```
@@finalType
ServerStatus {
    // The first block number available on this Block Node
    @@immutable firstAvailableBlock: uint64

    // The last block number available on this Block Node
    @@immutable lastAvailableBlock: uint64

    // A flag indicating this Block Node only offers the latest state snapshot (if applicable)
    @@immutable onlyLatestState: bool

    // Version information for address book, stream protocol, and software
    @@immutable versionInformation: BlockNodeVersions
}
```

#### BlockResult

Returned by **BlockQuery**; corresponds to `BlockResponse` from the Block Node `getBlock` RPC. Includes the response **code** so the SDK and caller can configure retry behavior. When **code** is SUCCESS, **block** is present.

```
@@finalType
BlockResult {
    // Protocol response code (SUCCESS, NOT_FOUND, NOT_AVAILABLE, etc.)
    @@immutable code: BlockAccessResponseCode

    // The requested block (present when code is SUCCESS)
    @@immutable @@nullable block: Block
}
```

#### StreamQuery (Abstract)

Abstract base type for streaming queries. **StreamQuery** must extend the SDK's existing Executable type—inheriting **setGrpcDeadline**, **setMaxAttempts**, **setMaxBackoff**, and getters—and defines only the stream-specific methods below. **BlockStreamQuery** extends **StreamQuery&lt;Block&gt;**. **TopicMessageQuery** should also extend **StreamQuery&lt;TopicMessage&gt;** if doing so is not a breaking change in the SDK's language; if it would be a breaking change, the SDK should implement the same handler and subscribe interface on **TopicMessageQuery** without requiring it to extend **StreamQuery**. Handlers need not be set by the caller; if a handler is not set, the SDK uses a default (e.g. no-op or logging).

```
abstraction StreamQuery<$$Item> extends Executable {
    // Set the handler called when the stream ends normally
    StreamQuery setCompletionHandler(handler: void callback())

    // Set the handler called when an error occurs (e.g. stream failure, retries exhausted); error type is the SDK's native error/exception type
    StreamQuery setErrorHandler(handler: void callback(error: $$Error))

    // Set the predicate that decides whether to retry after an error (e.g. true for NOT_AVAILABLE, false for INVALID_REQUEST); error type is the SDK's native error/exception type
    StreamQuery setRetryHandler(handler: bool callback(error: $$Error))

    // Subscribe to the stream; onNext is invoked for each item. Returns a SubscriptionHandle; caller calls unsubscribe() to stop.
    @@async
    @@throws(block-node-network-not-configured, block-node-grpc-status, invalid-block-range)
    SubscriptionHandle subscribe(client: Client, onNext: void callback(item: $$Item))
}
```

Note: `$$Error` is the SDK's native error/exception type (e.g. `Throwable` in Java, `Error` in JS, `error` in Go). SDKs should substitute the appropriate language-specific type.

- **subscribe(client, onNext)** – Opens the stream and invokes **onNext** for each item. Returns a **SubscriptionHandle**; the caller calls **unsubscribe()** to stop. The **client** is the client used to open the stream (Block Node client for BlockStreamQuery, mirror client for TopicMessageQuery).
- **setCompletionHandler** – The handler is invoked when the stream ends successfully (e.g. server closed with success, or bounded range completed). Must be implemented; if the caller does not set a handler, the SDK uses a default.
- **setErrorHandler** – The handler is invoked when an error occurs (e.g. after retries are exhausted, or when the application throws from **onNext**). Must be implemented; if the caller does not set a handler, the SDK uses a default.
- **setRetryHandler** – Given an error, returns whether to retry. Must be implemented; SDK defines and documents the default (e.g. retry on NOT_AVAILABLE, do not retry on INVALID_REQUEST).
- **Callback threading:** Following the pattern established by **TopicMessageQuery** across all SDKs, the **onNext** callback is invoked **sequentially** (one item at a time, never concurrently). The thread or context on which callbacks are invoked is SDK-specific (e.g. gRPC thread pool in Java, event loop in JavaScript, goroutine in Go, dedicated thread in Python, async context in Swift/Rust). Callers may safely call **unsubscribe()** from within the **onNext** callback.
- **SubscriptionHandle:** The canonical method to stop a subscription is **unsubscribe()**. SDKs may use language-idiomatic alternatives: Python's `SubscriptionHandle` uses `cancel()` instead of `unsubscribe()`; Swift uses async sequence cancellation; Rust uses native stream cancellation. The behavior (stop the stream, no further callbacks) must be the same regardless of the method name.

Concrete stream queries add only their own configuration: **BlockStreamQuery** adds **startBlockNumber** and **endBlockNumber** (via `@@getSet`); **TopicMessageQuery** adds **setTopicId**, **setStartTime**, **setEndTime**, **setLimit**, and their getters.

#### ServerStatusQuery

Query the status and capabilities of a Block Node.

```
@@finalType
ServerStatusQuery extends Executable<ServerStatus> {
    // No additional configuration - uses inherited execute(); setGrpcDeadline(), setMaxAttempts(), setMaxBackoff() from SDK's Executable type

    @@async
    @@throws(block-node-network-not-configured, block-node-grpc-status)
    ServerStatus execute(client: Client)
}
```

#### BlockQuery

Note: The `retrieveLatest` field is typed `@@nullable bool`. When the `blockNumber` variant of the oneOf is active, `retrieveLatest` is null. When `retrieveLatest` is active, it should always be set to `true`; a value of `false` is semantically equivalent to null (i.e., it means "not requesting latest").

```
@@finalType
@@oneOf(blockNumber, retrieveLatest)
BlockQuery extends Executable<BlockResult> {
    // Block number to retrieve. Mutually exclusive with retrieveLatest.
    @@getSet @@nullable blockNumber: uint64

    // When true, request the latest available block. Mutually exclusive with blockNumber.
    @@getSet @@nullable retrieveLatest: bool

    @@async
    @@throws(block-node-network-not-configured, block-node-grpc-status, invalid-request, block-not-found, block-not-available)
    BlockResult execute(client: Client)
}
```

#### BlockStreamQuery

Subscribe to a stream of blocks from a Block Node. **BlockStreamQuery** must extend **StreamQuery&lt;Block&gt;** and adds only block-range configuration (start/end block number). Completion handler, error handler, retry handler, and **subscribe** are inherited from **StreamQuery**. The underlying gRPC stream delivers block items in batches and an end-of-block marker per block; the SDK assembles these into full **Block** values and invokes the callback once per completed block (see [Block stream subscription behavior](#block-stream-subscription-behavior)). Callers use **subscribe(client, onNext)** and collect blocks in the callback until the stream ends or they call **unsubscribe()**.

```
@@finalType
BlockStreamQuery extends StreamQuery<Block> {
    // The starting block number; defaults to 0 (genesis block)
    @@getSet @@default(0) startBlockNumber: uint64

    // The ending block number; if not set (null), the stream continues indefinitely.
    // On the wire the SDK sends uint64_max (0xFFFFFFFFFFFFFFFF) when this field is null.
    @@getSet @@nullable endBlockNumber: uint64
}
```

---

### namespace blockStream

requires blockNode, state, proofs, legacy

Types representing block stream data: blocks, block items, headers, transaction results, transaction outputs, filtered/redacted items, trace data, and the block container itself.

#### BlockItemType

Types of items that can be contained in a block.

```
enum BlockItemType {
    BLOCK_HEADER
    EVENT_HEADER
    ROUND_HEADER
    SIGNED_TRANSACTION
    TRANSACTION_RESULT
    TRANSACTION_OUTPUT
    STATE_CHANGES
    FILTERED_SINGLE_ITEM
    BLOCK_PROOF
    RECORD_FILE
    TRACE_DATA
    BLOCK_FOOTER
    REDACTED_ITEM
}
```

#### BlockHashAlgorithm

Hash algorithm used for a block.

```
enum BlockHashAlgorithm {
    SHA2_384
}
```

#### BlockHeader

The header of a block containing metadata.

```
@@finalType
BlockHeader {
    // A version of the HAPI specification used to serialize the block
    @@immutable hapiProtoVersion: SemanticVersion

    // A version of the consensus node software that executed transactions in this block
    @@immutable softwareVersion: SemanticVersion

    // The block number (must be exactly 1 more than previous block)
    @@immutable number: uint64

    // The timestamp for this block (consensus time of first round in the block)
    @@immutable blockTimestamp: dateTime

    // The hash algorithm used for this block, including the block proof
    @@immutable hashAlgorithm: BlockHashAlgorithm
}
```

#### BlockItem

An individual item within a block.

```
@@finalType
@@oneOf(blockHeader, eventHeader, roundHeader, signedTransaction, transactionResult, transactionOutput, stateChanges, filteredSingleItem, blockProof, recordFile, traceData, blockFooter, redactedItem)
BlockItem {
    @@immutable @@nullable blockHeader: BlockHeader
    @@immutable @@nullable eventHeader: EventHeader
    @@immutable @@nullable roundHeader: RoundHeader
    @@immutable @@nullable signedTransaction: bytes
    @@immutable @@nullable transactionResult: TransactionResult
    @@immutable @@nullable transactionOutput: TransactionOutput
    @@immutable @@nullable stateChanges: StateChanges
    @@immutable @@nullable filteredSingleItem: FilteredSingleItem
    @@immutable @@nullable blockProof: BlockProof
    @@immutable @@nullable recordFile: RecordFileItem
    @@immutable @@nullable traceData: TraceData
    @@immutable @@nullable blockFooter: BlockFooter
    @@immutable @@nullable redactedItem: RedactedItem
}
```

#### EventCore

Core data for a network gossip event.

```
@@finalType
EventCore {
    // The unique identifier for the node that created the event
    @@immutable creatorNodeId: int64

    // The birth round of the event (pending consensus round when created)
    @@immutable birthRound: int64

    // The wall clock time when the latest information affecting this event was received
    @@immutable timeCreated: dateTime

    // A random number used to break ties in the consensus algorithm (value range: 0 to roster size, inclusive)
    @@immutable coin: int64
}
```

#### EventDescriptor

Unique identifier for a consensus/gossip event. Used when referencing a parent event that lies outside the containing block (see **ParentEventReference**). The descriptor is derived from the event (e.g. hash of EventCore plus transaction hashes); it uniquely identifies the event across the network.

```
@@finalType
EventDescriptor {
    // SHA-384 hash of the event (EventCore bytes plus hashes of event transactions, in order)
    @@immutable hash: bytes

    // Unique identifier for the node that created the event (matches address book)
    @@immutable creatorNodeId: int64

    // Birth round: the pending consensus round when the event was created (one greater than latest round to reach consensus)
    @@immutable birthRound: int64
}
```

#### ParentEventReference

A reference to a parent event in the consensus graph.

```
@@finalType
@@oneOf(eventDescriptor, index)
ParentEventReference {
    // An EventDescriptor for the parent event outside of the containing block
    @@immutable @@nullable eventDescriptor: EventDescriptor

    // An index of the parent event within the containing block
    @@immutable @@nullable index: uint32
}
```

#### EventHeader

A header for a single network gossip event, containing information about the event and its parents.

```
@@finalType
EventHeader {
    // Core event data including creator, birth round, and timestamp
    @@immutable eventCore: EventCore

    // List of references to parent events
    @@immutable parents: list<ParentEventReference>
}
```

#### RoundHeader

A header for a single consensus round, marking the start of a new round.

```
@@finalType
RoundHeader {
    // The round number assigned for consensus
    @@immutable roundNumber: uint64
}
```

#### TransactionResult

The result of running a transaction (receipt information).

```
@@finalType
TransactionResult {
    // The status code indicating success or a specific failure
    @@immutable status: Status

    // The consensus timestamp when this transaction reached consensus
    @@immutable consensusTimestamp: dateTime

    // The parent consensus timestamp for child transactions (null for user-submitted)
    @@immutable @@nullable parentConsensusTimestamp: dateTime

    // A schedule that executed this transaction, if scheduled
    @@immutable @@nullable scheduleRef: ScheduleId

    // The actual transaction fee charged (in tinybar)
    @@immutable transactionFeeCharged: uint64

    // All HBAR transfers completed as a result of this transaction
    @@immutable transfers: list<Transfer>

    // All non-HBAR token transfers completed as a result of this transaction
    @@immutable tokenTransferLists: list<TokenTransferList>

    // Token associations created automatically during this transaction
    @@immutable automaticTokenAssociations: list<TokenAssociation>

    // Accounts paid staking rewards as a result of this transaction
    @@immutable paidStakingRewards: list<Transfer>

    // The congestion pricing multiplier applied to transaction fees
    @@immutable congestionPricingMultiplier: uint64

    // Custom fees assessed during transaction execution
    @@immutable assessedCustomFees: list<AssessedCustomFee>
}
```

Note: These types are provided by existing SDK wrapper types. **Status** (transaction/response code)—Java, Go, JS, C++, Swift use `Status`; Python uses `ResponseCode`. **Transfer** wraps the proto `AccountAmount` (an account and an HBAR amount); SDKs already have this type (Java/JS/Swift/Rust: `Transfer`; Go: `Transfer`; C++: `HbarTransfer`; Python: `HbarTransfer`). **TokenTransferList**, **TokenAssociation** (missing in Python; must be added), **AssessedCustomFee**, **ScheduleId**—existing SDK wrapper types. SDKs must not expose raw proto for these; use the same wrapper types when exposing **TransactionResult** from Block Node data. Note: The proto `TransactionResult.transfer_list` is a `TransferList` message containing `repeated AccountAmount`; SDKs must unwrap this into `list<Transfer>`.

#### TransactionOutput

Output from a transaction that is not in the transaction body or state changes. Each variant corresponds to one transaction type; exactly one variant is set per **TransactionOutput**.

```
@@finalType
@@oneOf(utilPrng, contractCall, ethereumCall, contractCreate, createSchedule, signSchedule, accountCreate)
TransactionOutput {
    // Output from a utilPrng transaction
    @@immutable @@nullable utilPrng: UtilPrngOutput

    // Output from a contract call transaction
    @@immutable @@nullable contractCall: CallContractOutput

    // Output from an ethereum call transaction
    @@immutable @@nullable ethereumCall: EthereumOutput

    // Output from a contract create transaction
    @@immutable @@nullable contractCreate: CreateContractOutput

    // Output from a schedule create transaction that executed immediately
    @@immutable @@nullable createSchedule: CreateScheduleOutput

    // Output from a schedule sign transaction that executed the scheduled transaction
    @@immutable @@nullable signSchedule: SignScheduleOutput

    // Output from a transaction that includes account creation
    @@immutable @@nullable accountCreate: CreateAccountOutput
}
```

These output types are not currently first-class types in the SDKs; they are defined in the block stream protos. SDKs must expose them when exposing **BlockItem** and **TransactionOutput** (e.g. from Block Node block stream or transaction records). Definitions follow.

##### UtilPrngOutput

Block stream output for a Util PRNG transaction. Exactly one of **prngBytes** or **prngNumber** is set.

```
@@finalType
@@oneOf(prngBytes, prngNumber)
UtilPrngOutput {
    // Deterministic pseudo-random 48-byte sequence (when transaction did not request a range)
    @@immutable @@nullable prngBytes: bytes

    // Deterministic pseudo-random number in the requested range (when transaction specified a range)
    @@immutable @@nullable prngNumber: uint32
}
```

##### EvmTransactionResult

Results of executing an EVM transaction in the block stream. This is a **separate type** from the existing SDK `ContractFunctionResult`; `ContractFunctionResult` wraps the legacy `ContractFunctionResult` proto used in query responses and transaction records, while `EvmTransactionResult` wraps the `EvmTransactionResult` proto from `services/contract_types.proto` used in block stream output. SDKs must define this as a new wrapper type.

```
@@finalType
EvmTransactionResult {
    // The Hedera account id of the caller
    @@immutable @@nullable senderId: AccountId

    // The contract receiving the call
    @@immutable @@nullable contractId: ContractId

    // Result data from the function call
    @@immutable resultData: bytes

    // Error message produced by the contract call; empty string if unset
    @@immutable errorMessage: string

    // EVM gas used
    @@immutable gasUsed: uint64

    // Context of the internal call producing this result, if not already in the transaction body
    @@immutable @@nullable internalCallContext: InternalCallContext

    // Id of the executed hook, if applicable
    @@immutable @@nullable executedHookId: HookId

    // Contract account nonce values modified as a result of this call
    @@immutable contractNonces: list<ContractNonceInfo>

    // In an EthereumTransaction, the nonce of the signer account at end of transaction
    @@immutable @@nullable signerNonce: int64
}
```

##### InternalCallContext

Context of an internal call in an EVM transaction. Aligns with `InternalCallContext` in services/contract_types.proto.

```
@@finalType
InternalCallContext {
    // The gas available for the call
    @@immutable gas: uint64

    // The value sent with the call
    @@immutable value: uint64

    // The call data for the call
    @@immutable callData: bytes
}
```

##### ContractNonceInfo

A contract nonce reference. Aligns with `ContractNonceInfo` in services/contract_types.proto.

```
@@finalType
ContractNonceInfo {
    // The contract that holds this nonce value
    @@immutable contractId: ContractId

    // The current nonce value
    @@immutable nonce: int64
}
```

##### CallContractOutput

Block stream output for a contract call transaction.

```
@@finalType
CallContractOutput {
    // EVM transaction result (return data, gas used, etc.)
    @@immutable evmTransactionResult: EvmTransactionResult
}
```

##### CreateContractOutput

Block stream output for a contract create transaction.

```
@@finalType
CreateContractOutput {
    // EVM transaction result for the creation
    @@immutable evmTransactionResult: EvmTransactionResult
}
```

##### EthereumOutput

Block stream output for an Ethereum-style transaction. Exactly one of **evmCallTransactionResult** or **evmCreateTransactionResult** is set.

```
@@finalType
@@oneOf(evmCallTransactionResult, evmCreateTransactionResult)
EthereumOutput {
    // EVM result when the transaction was executed as a call
    @@immutable @@nullable evmCallTransactionResult: EvmTransactionResult

    // EVM result when the transaction was executed as a create
    @@immutable @@nullable evmCreateTransactionResult: EvmTransactionResult
}
```

##### CreateScheduleOutput

Block stream output for a schedule create transaction. **scheduleId** is set on success (or when an identical schedule already exists). **scheduledTransactionId** is set only when the scheduled child transaction executed immediately (e.g. sufficient signatures provided at create time).

```
@@finalType
CreateScheduleOutput {
    // The created (or existing identical) schedule identifier
    @@immutable @@nullable scheduleId: ScheduleId

    // Transaction ID of the scheduled child, if it executed as part of this transaction
    @@immutable @@nullable scheduledTransactionId: TransactionId
}
```

##### SignScheduleOutput

Block stream output for a schedule sign transaction. **scheduledTransactionId** is set only when this sign caused the scheduled child transaction to execute.

```
@@finalType
SignScheduleOutput {
    // Transaction ID of the scheduled child, if it executed as part of this sign
    @@immutable @@nullable scheduledTransactionId: TransactionId
}
```

##### CreateAccountOutput

Block stream output for any transaction that creates an account (e.g. crypto create account).

```
@@finalType
CreateAccountOutput {
    // The newly created account identifier
    @@immutable createdAccountId: AccountId
}
```

#### SubMerkleTree

Identifier for each sub-tree of the block root fixed-size merkle tree.

```
enum SubMerkleTree {
    ITEM_TYPE_UNSPECIFIED
    PREVIOUS_BLOCK_ROOT
    PREVIOUS_ROOTS_TREE
    PREVIOUS_BLOCK_START_STATE
    CONSENSUS_HEADER_ITEMS
    INPUT_ITEMS_TREE
    OUTPUT_ITEMS_TREE
    STATE_CHANGE_ITEMS_TREE
    TRACE_DATA_ITEMS_TREE
}
```

Note: The protobuf defines additional reserved values (`FUTURE_1` through `FUTURE_8`, values 9–16) for future sub-tree types. SDKs must handle unrecognized enum values gracefully (e.g. by mapping to `ITEM_TYPE_UNSPECIFIED` or an SDK-specific unknown variant) so that blocks containing future sub-tree types do not cause deserialization failures.

#### FilteredSingleItem

A block item that was intentionally filtered from the stream.

```
@@finalType
FilteredSingleItem {
    // A hash of the item that was filtered from the stream
    @@immutable itemHash: bytes

    // Identifies which block merkle sub-tree the hash belongs to
    @@immutable tree: SubMerkleTree
}
```

#### RedactedItem

A block item that was intentionally redacted from the stream.

```
@@finalType
RedactedItem {
    // A hash of the item that was redacted from the stream
    @@immutable itemHash: bytes

    // Hash of the SignedTransaction directly (for event reconstruction); empty bytes if unset
    @@immutable signedTransactionHash: bytes

    // Identifies which block merkle sub-tree the hash belongs to
    @@immutable tree: SubMerkleTree
}
```

#### BlockFooter

A collection of hashes at the end of each block, needed to compute the block's root hash.

```
@@finalType
BlockFooter {
    // The root hash of the previous block (empty for genesis block)
    @@immutable previousBlockRootHash: bytes

    // The root hash of a merkle tree containing all block hashes from block zero
    @@immutable rootHashOfAllBlockHashesTree: bytes

    // The merkle root hash of the network state at the start of the current block
    @@immutable startOfBlockStateRootHash: bytes
}
```

#### TraceData

Trace or debugging data for a transaction, such as EVM execution traces. Exactly one of **evmTraceData** or **submitMessageTraceData** is set.

```
@@finalType
@@oneOf(evmTraceData, submitMessageTraceData)
TraceData {
    @@immutable @@nullable evmTraceData: EvmTraceData
    @@immutable @@nullable submitMessageTraceData: SubmitMessageTraceData
}
```

##### EvmTraceData

EVM trace data for smart contract transactions (contract actions, slot usage, error details, initcode, logs). Aligns with `EvmTraceData` in block/stream/trace/smart_contract_service.proto. Nested types are defined below; SDKs must expose them as wrapper types.

```
@@finalType
EvmTraceData {
    // All contract actions executed during the transaction
    @@immutable contractActions: list<ContractAction>

    // Contract slot usages by contract id
    @@immutable contractSlotUsages: list<ContractSlotUsage>

    // Error message details if the contract call failed; empty string if unset
    @@immutable errorDetails: string

    // Initcode executed for an internal contract creation
    @@immutable @@nullable executedInitcode: ExecutedInitcode

    // Log events produced during the transaction, by contract id
    @@immutable logs: list<EvmTransactionLog>
}
```

**ContractAction**

A single action (call, create, etc.) executed during a contract transaction. Aligns with `ContractAction` in streams/contract_action.proto.

```
@@finalType
@@oneOf(callingAccount, callingContract)
@@oneOf(recipientAccount, recipientContract, targetedAddress)
@@oneOf(output, revertReason, error)
ContractAction {
    // The type of this action
    @@immutable callType: ContractActionType

    // If the caller was a regular account
    @@immutable @@nullable callingAccount: AccountId

    // If the caller was a smart contract
    @@immutable @@nullable callingContract: ContractId

    // The upper limit of gas this action can spend
    @@immutable gas: int64

    // Bytes passed in as input data to this action
    @@immutable input: bytes

    // The AccountId of the recipient if the recipient is an account
    @@immutable @@nullable recipientAccount: AccountId

    // The ContractId of the recipient if the recipient is a smart contract
    @@immutable @@nullable recipientContract: ContractId

    // The targeted address bytes on failed executions (address did not correspond to any account or contract)
    @@immutable @@nullable targetedAddress: bytes

    // The value (in tinybars) associated with this action
    @@immutable value: int64

    // The actual gas spent by this action
    @@immutable gasUsed: int64

    // If successful, the output bytes of the action
    @@immutable @@nullable output: bytes

    // The contract caused the transaction to fail via REVERT
    @@immutable @@nullable revertReason: bytes

    // The transaction failed without an explicit REVERT
    @@immutable @@nullable error: bytes

    // The nesting depth of this call (original action is depth=0)
    @@immutable callDepth: int32

    // The call operation type
    @@immutable callOperationType: CallOperationType
}
```

**ContractActionType**

Type of action in a contract call trace. Aligns with `ContractActionType` in streams/contract_action.proto.

```
enum ContractActionType {
    NO_ACTION
    CALL
    CREATE
    PRECOMPILE
    SYSTEM
}
```

**CallOperationType**

The specific EVM operation type of a call. Aligns with `CallOperationType` in streams/contract_action.proto.

```
enum CallOperationType {
    OP_UNKNOWN
    OP_CALL
    OP_CALLCODE
    OP_DELEGATECALL
    OP_STATICCALL
    OP_CREATE
    OP_CREATE2
}
```

**ContractSlotUsage**

Storage slot usage by a contract during an EVM transaction. Aligns with `ContractSlotUsage` in block/stream/trace/smart_contract_service.proto.

```
@@finalType
ContractSlotUsage {
    // The contract using the storage slots
    @@immutable contractId: ContractId

    // Slot keys written by this EVM transaction
    @@immutable @@nullable writtenSlotKeys: WrittenSlotKeys

    // Storage slots read during this EVM execution
    @@immutable slotReads: list<SlotRead>
}
```

```
@@finalType
WrittenSlotKeys {
    @@immutable keys: list<bytes>
}
```

```
@@finalType
@@oneOf(index, key)
SlotRead {
    // If this slot was also written, the index of the written key
    @@immutable @@nullable index: int32

    // If this slot was only read, its key (minimal bytes, left-pad with zeros for 32-byte EVM key)
    @@immutable @@nullable key: bytes

    // The storage value in this slot (minimal bytes, left-pad with zeros for 32-byte EVM value)
    @@immutable readValue: bytes
}
```

**ExecutedInitcode**

Initcode executed for an internal contract creation. Aligns with `ExecutedInitcode` in block/stream/trace/smart_contract_service.proto.

```
@@finalType
@@oneOf(initcodeBookends, explicitInitcode)
ExecutedInitcode {
    // The id of the contract created by the initcode
    @@immutable contractId: ContractId

    // If runtime bytecode is a subsequence of initcode, the surrounding pieces
    @@immutable @@nullable initcodeBookends: InitcodeBookends

    // If runtime bytecode is not a subsequence of initcode, the explicit initcode bytes
    @@immutable @@nullable explicitInitcode: bytes
}
```

```
@@finalType
InitcodeBookends {
    // Bytecode preceding the runtime bytecode in initcode
    @@immutable deployBytecode: bytes

    // Bytecode following the runtime bytecode in initcode
    @@immutable metadataBytecode: bytes
}
```

**EvmTransactionLog**

A log event emitted by a contract during an EVM transaction. Aligns with `EvmTransactionLog` in block/stream/trace/smart_contract_service.proto.

```
@@finalType
EvmTransactionLog {
    // The contract emitting the log
    @@immutable contractId: ContractId

    // The logged data
    @@immutable data: bytes

    // The log's topics (minimal bytes, left-pad with zeros for 256-bit words)
    @@immutable topics: list<bytes>
}
```

##### SubmitMessageTraceData

Trace data for ConsensusSubmitMessage transactions (e.g. in an atomic batch). Aligns with `SubmitMessageTraceData` in block/stream/trace/consensus_service.proto.

```
@@finalType
SubmitMessageTraceData {
    // Sequence number assigned to this message within the topic
    @@immutable sequenceNumber: int64

    // Running hash of the topic after incorporating this message
    @@immutable runningHash: bytes
}
```

#### Block

A verified block from the block stream. Used as the payload in **BlockResult** (from BlockQuery), in **BlockStreamQuery** callbacks, and in proofs.

```
@@finalType
Block {
    // The block items contained in this block (begins with BlockHeader, ends with BlockProof)
    @@immutable items: list<BlockItem>
}
```

---

### namespace stateChanges

requires blockStream, state

Types representing state change infrastructure: the containers, keys, values, and change operations that describe mutations to network state within a block.

#### StateChanges

A set of state changes that mutate network state at a specific consensus timestamp.

```
@@finalType
StateChanges {
    // The consensus timestamp of this set of changes
    @@immutable consensusTimestamp: dateTime

    // An ordered list of individual state changes (must be applied in order)
    @@immutable stateChanges: list<StateChange>
}
```

#### StateChange

A single change to an item in the network state merkle tree. Exactly one of the change variants is set per **StateChange**. These types are not currently first-class SDK types (the SDK **ContractStateChange** is a different, deprecated concept for contract storage changes). SDKs must expose them when exposing **StateChanges** from block stream **BlockItem**s.

```
@@finalType
@@oneOf(stateAdd, stateRemove, singletonUpdate, mapUpdate, mapDelete, queuePush, queuePop)
StateChange {
    // A state identifier indicating which merkle subtree is being modified
    @@immutable stateId: uint32

    // Addition of a new state (singleton, virtual map, or queue)
    @@immutable @@nullable stateAdd: NewStateChange

    // Removal of an existing state
    @@immutable @@nullable stateRemove: RemovedStateChange

    // An add or update to a Singleton state
    @@immutable @@nullable singletonUpdate: SingletonUpdateChange

    // An add or update to a single item in a VirtualMap
    @@immutable @@nullable mapUpdate: MapUpdateChange

    // A removal of a single item from a VirtualMap
    @@immutable @@nullable mapDelete: MapDeleteChange

    // Addition of an item to a Queue state
    @@immutable @@nullable queuePush: QueuePushChange

    // Removal of an item from a Queue state
    @@immutable @@nullable queuePop: QueuePopChange
}
```

##### NewStateChange

Addition of a new named state (singleton, virtual map, or queue). The content is filled by subsequent state changes.

```
@@finalType
NewStateChange {
    // Type of state being added
    @@immutable stateType: NewStateType
}

enum NewStateType {
    SINGLETON
    VIRTUAL_MAP
    QUEUE
}
```

##### RemovedStateChange

Removal of an existing named state (the entire singleton, virtual map, or queue). No additional fields beyond **StateChange.stateId**.

```
@@finalType
RemovedStateChange {
    // No fields - stateId in parent StateChange identifies the state removed
}
```

##### SingletonUpdateChange

An add or update to a **Singleton** state. The new value is one of many possible singleton types. Aligns with `SingletonUpdateChange` in block/stream/output/state_changes.proto. SDKs must expose **SingletonUpdateChange** as a wrapper type (e.g. a type with a oneof or accessors over wrapper types for each singleton variant). Do not expose proto-generated types; define or reuse wrapper types for each singleton value kind.

```
@@finalType
@@oneOf(blockInfoValue, congestionLevelStartsValue, entityNumberValue, exchangeRateSetValue, networkStakingRewardsValue, bytesValue, stringValue, runningHashesValue, throttleUsageSnapshotsValue, timestampValue, blockStreamInfoValue, platformStateValue, rosterStateValue, hintsConstructionValue, entityCountsValue, historyProofConstructionValue, crsStateValue, nodeRewardsValue, nodePaymentsValue)
SingletonUpdateChange {
    @@immutable @@nullable blockInfoValue: BlockInfo
    @@immutable @@nullable congestionLevelStartsValue: CongestionLevelStarts
    @@immutable @@nullable entityNumberValue: uint64
    @@immutable @@nullable exchangeRateSetValue: ExchangeRates
    @@immutable @@nullable networkStakingRewardsValue: NetworkStakingRewards
    @@immutable @@nullable bytesValue: bytes
    @@immutable @@nullable stringValue: string
    @@immutable @@nullable runningHashesValue: RunningHashes
    @@immutable @@nullable throttleUsageSnapshotsValue: ThrottleUsageSnapshots
    @@immutable @@nullable timestampValue: dateTime
    @@immutable @@nullable blockStreamInfoValue: BlockStreamInfo
    @@immutable @@nullable platformStateValue: PlatformState
    @@immutable @@nullable rosterStateValue: RosterState
    @@immutable @@nullable hintsConstructionValue: HintsConstruction
    @@immutable @@nullable entityCountsValue: EntityCounts
    @@immutable @@nullable historyProofConstructionValue: HistoryProofConstruction
    @@immutable @@nullable crsStateValue: CRSState
    @@immutable @@nullable nodeRewardsValue: NodeRewards
    @@immutable @@nullable nodePaymentsValue: NodePayments
}
```

Note: The `exchangeRateSetValue` field maps to `proto.ExchangeRateSet` on the wire. SDKs must use their existing `ExchangeRates` wrapper type (or `ExchangeRate` in Go) to expose this value.

##### MapChangeKey

Key identifying a specific entry in a virtual map. Exactly one variant is set; the variant depends on the map (stateId). Aligns with `MapChangeKey` in block/stream/output/state_changes.proto. SDKs must expose as a wrapper with getters or variant accessors; use existing SDK types where applicable; for platform/state types (TSS, hints, history, hooks), SDKs define wrapper types per block stream spec.

```
@@finalType
@@oneOf(accountIdKey, tokenRelationshipKey, entityNumberKey, fileIdKey, nftIdKey, protoBytesKey, protoLongKey, protoStringKey, scheduleIdKey, slotKeyKey, tokenIdKey, topicIdKey, contractIdKey, pendingAirdropIdKey, timestampSecondsKey, scheduledOrderKey, tssMessageMapKey, tssVoteMapKey, hintsPartyIdKey, preprocessingVoteIdKey, nodeIdKey, constructionNodeIdKey, hookIdKey, evmHookSlotKey)
MapChangeKey {
    @@immutable @@nullable accountIdKey: AccountId
    @@immutable @@nullable tokenRelationshipKey: TokenAssociation
    @@immutable @@nullable entityNumberKey: uint64
    @@immutable @@nullable fileIdKey: FileId
    @@immutable @@nullable nftIdKey: NftId
    @@immutable @@nullable protoBytesKey: bytes
    @@immutable @@nullable protoLongKey: int64
    @@immutable @@nullable protoStringKey: string
    @@immutable @@nullable scheduleIdKey: ScheduleId
    @@immutable @@nullable slotKeyKey: SlotKey
    @@immutable @@nullable tokenIdKey: TokenId
    @@immutable @@nullable topicIdKey: TopicId
    @@immutable @@nullable contractIdKey: ContractId
    @@immutable @@nullable pendingAirdropIdKey: PendingAirdropId
    @@immutable @@nullable timestampSecondsKey: TimestampSeconds
    @@immutable @@nullable scheduledOrderKey: ScheduledOrder
    @@immutable @@nullable tssMessageMapKey: TssMessageMapKey
    @@immutable @@nullable tssVoteMapKey: TssVoteMapKey
    @@immutable @@nullable hintsPartyIdKey: HintsPartyId
    @@immutable @@nullable preprocessingVoteIdKey: PreprocessingVoteId
    @@immutable @@nullable nodeIdKey: uint64
    @@immutable @@nullable constructionNodeIdKey: ConstructionNodeId
    @@immutable @@nullable hookIdKey: HookId
    @@immutable @@nullable evmHookSlotKey: EvmHookSlotKey
}
```

##### MapChangeValue

Value updated in or added to a virtual map. Exactly one variant is set. Aligns with `MapChangeValue` in block/stream/output/state_changes.proto. SDKs must expose as a wrapper; use existing SDK types where applicable; for platform/state types (TSS, hints, history, hooks, addressbook), SDKs define wrapper types per block stream spec.

```
@@finalType
@@oneOf(accountValue, accountIdValue, bytecodeValue, fileValue, nftValue, protoStringValue, scheduleValue, scheduleListValue, slotValueValue, stakingNodeInfoValue, tokenValue, tokenRelationValue, topicValue, nodeValue, accountPendingAirdropValue, rosterValue, scheduledCountsValue, scheduleIdValue, throttleUsageSnapshotsValue, tssEncryptionKeysValue, tssMessageValue, tssVoteValue, hintsKeySetValue, preprocessingVoteValue, crsPublicationValue, historySignatureValue, historyProofVoteValue, proofKeySetValue, evmHookStateValue, nodeIdValue, wrapsMessageHistoryValue)
MapChangeValue {
    @@immutable @@nullable accountValue: Account
    @@immutable @@nullable accountIdValue: AccountId
    @@immutable @@nullable bytecodeValue: Bytecode
    @@immutable @@nullable fileValue: File
    @@immutable @@nullable nftValue: Nft
    @@immutable @@nullable protoStringValue: string
    @@immutable @@nullable scheduleValue: Schedule
    @@immutable @@nullable scheduleListValue: ScheduleList
    @@immutable @@nullable slotValueValue: SlotValue
    @@immutable @@nullable stakingNodeInfoValue: StakingNodeInfo
    @@immutable @@nullable tokenValue: Token
    @@immutable @@nullable tokenRelationValue: TokenRelation
    @@immutable @@nullable topicValue: Topic
    @@immutable @@nullable nodeValue: Node
    @@immutable @@nullable accountPendingAirdropValue: AccountPendingAirdrop
    @@immutable @@nullable rosterValue: Roster
    @@immutable @@nullable scheduledCountsValue: ScheduledCounts
    @@immutable @@nullable scheduleIdValue: ScheduleId
    @@immutable @@nullable throttleUsageSnapshotsValue: ThrottleUsageSnapshots
    @@immutable @@nullable tssEncryptionKeysValue: TssEncryptionKeys
    @@immutable @@nullable tssMessageValue: TssMessageTransactionBody
    @@immutable @@nullable tssVoteValue: TssVoteTransactionBody
    @@immutable @@nullable hintsKeySetValue: HintsKeySet
    @@immutable @@nullable preprocessingVoteValue: PreprocessingVote
    @@immutable @@nullable crsPublicationValue: CrsPublicationTransactionBody
    @@immutable @@nullable historySignatureValue: RecordedHistorySignature
    @@immutable @@nullable historyProofVoteValue: HistoryProofVote
    @@immutable @@nullable proofKeySetValue: ProofKeySet
    @@immutable @@nullable evmHookStateValue: EvmHookState
    @@immutable @@nullable nodeIdValue: uint64
    @@immutable @@nullable wrapsMessageHistoryValue: WrapsMessageHistory
}
```

##### MapUpdateChange

An add or update to a single entry in a **VirtualMap** state. Uses **MapChangeKey** and **MapChangeValue** (defined above). SDKs must expose as wrapper types.

```
@@finalType
MapUpdateChange {
    // Key of the entry to add or update
    @@immutable key: MapChangeKey

    // New value of the entry
    @@immutable value: MapChangeValue

    // If true, the value is identical to the previous value (no effective change)
    @@immutable identical: bool
}
```

##### MapDeleteChange

Removal of a single entry from a **VirtualMap** state.

```
@@finalType
MapDeleteChange {
    // Key of the entry to remove
    @@immutable key: MapChangeKey
}
```

##### QueuePushChange

Addition of an item to a **Queue** state (after the current last element).

```
@@finalType
@@oneOf(protoBytesElement, protoStringElement, transactionReceiptEntriesElement)
QueuePushChange {
    @@immutable @@nullable protoBytesElement: bytes
    @@immutable @@nullable protoStringElement: string
    // Transaction receipt entries for a round; SDKs must expose as a wrapper type (e.g. TransactionReceiptEntries)
    @@immutable @@nullable transactionReceiptEntriesElement: TransactionReceiptEntries
}
```

##### TransactionReceiptEntry

A single receipt entry in the record cache (node that submitted, transaction ID, status). Aligns with `TransactionReceiptEntry` in services/state/recordcache/recordcache.proto.

```
@@finalType
TransactionReceiptEntry {
    // Node identifier (address book) that submitted the transaction to consensus
    @@immutable nodeId: uint64

    // Transaction identifier for this receipt
    @@immutable transactionId: TransactionId

    // Final status after handling the transaction (use SDK Status/ResponseCode type)
    @@immutable status: Status
}
```

##### TransactionReceiptEntries

List of transaction receipt entries (e.g. all receipts for a round in queue state). Aligns with `TransactionReceiptEntries` in services/state/recordcache/recordcache.proto.

```
@@finalType
TransactionReceiptEntries {
    @@immutable entries: list<TransactionReceiptEntry>
}
```

Note: **TransactionId** and **Status** are existing SDK types. SDKs must expose **TransactionReceiptEntries** and **TransactionReceiptEntry** as wrapper types.

##### QueuePopChange

Removal of the front (head) item from a **Queue** state. No additional fields beyond **StateChange.stateId**.

```
@@finalType
QueuePopChange {
    // No fields - stateId in parent StateChange identifies the queue
}
```

#### StateIdentifier

An enumeration mapping the integer `stateId` in **StateChange** to a meaningful state name. This enum is not transmitted on the wire; it provides a lookup for interpreting `StateChange.stateId` values. SDKs must define this as a public enum. Unrecognized values must be handled gracefully (e.g. mapped to `UNKNOWN`).

```
enum StateIdentifier {
    UNKNOWN
    STATE_ID_ENTITY_ID
    STATE_ID_ACCOUNTS
    STATE_ID_ALIASES
    STATE_ID_STORAGE
    STATE_ID_BYTECODE
    STATE_ID_FILES
    STATE_ID_TOKENS
    STATE_ID_NFTS
    STATE_ID_TOKEN_RELS
    STATE_ID_STAKING_INFOS
    STATE_ID_STAKING_NETWORK_REWARDS
    STATE_ID_THROTTLE_USAGE_SNAPSHOTS
    STATE_ID_CONGESTION_LEVEL_STARTS
    STATE_ID_SCHEDULES_BY_ID
    STATE_ID_SCHEDULES_BY_EXPIRY_SEC
    STATE_ID_SCHEDULES_BY_EQUALITY
    STATE_ID_MIDNIGHT_RATES
    STATE_ID_RUNNING_HASHES
    STATE_ID_BLOCKS
    STATE_ID_NODES
    STATE_ID_TOPICS
    STATE_ID_UPGRADE_FILE_HASH
    STATE_ID_FREEZE_TIME
    STATE_ID_BLOCK_STREAM_INFO
    STATE_ID_PENDING_AIRDROPS
    STATE_ID_PLATFORM_STATE
    STATE_ID_ROSTER_STATE
    STATE_ID_ROSTERS
    STATE_ID_SCHEDULED_COUNTS
    STATE_ID_SCHEDULE_ID_BY_EQUALITY
    STATE_ID_TSS_MESSAGES
    STATE_ID_TSS_VOTES
    STATE_ID_SCHEDULED_ORDERS
    STATE_ID_SCHEDULED_USAGES
    STATE_ID_TSS_ENCRYPTION_KEYS
    STATE_ID_TSS_STATUS
    STATE_ID_HINTS_KEY_SETS
    STATE_ID_ACTIVE_HINTS_CONSTRUCTION
    STATE_ID_NEXT_HINTS_CONSTRUCTION
    STATE_ID_PREPROCESSING_VOTES
    STATE_ID_ENTITY_COUNTS
    STATE_ID_LEDGER_ID
    STATE_ID_PROOF_KEY_SETS
    STATE_ID_ACTIVE_PROOF_CONSTRUCTION
    STATE_ID_NEXT_PROOF_CONSTRUCTION
    STATE_ID_HISTORY_SIGNATURES
    STATE_ID_PROOF_VOTES
    STATE_ID_CRS_STATE
    STATE_ID_CRS_PUBLICATIONS
    STATE_ID_NODE_REWARDS
    STATE_ID_EVM_HOOK_STATES
    STATE_ID_EVM_HOOK_STORAGE
    STATE_ID_ACCOUNT_NODE_REL
    STATE_ID_WRAPS_MESSAGE_HISTORIES
    STATE_ID_NODE_PAYMENTS
    STATE_ID_TRANSACTION_RECEIPTS
    STATE_ID_UPGRADE_DATA_150
    STATE_ID_UPGRADE_DATA_151
    STATE_ID_UPGRADE_DATA_152
    STATE_ID_UPGRADE_DATA_153
    STATE_ID_UPGRADE_DATA_154
    STATE_ID_UPGRADE_DATA_155
    STATE_ID_UPGRADE_DATA_156
    STATE_ID_UPGRADE_DATA_157
    STATE_ID_UPGRADE_DATA_158
    STATE_ID_UPGRADE_DATA_159

    // The integer value corresponding to the proto StateIdentifier enum
    @@immutable value: uint32
}
```

---

### namespace state

Types representing network entity state, platform state, and configuration singletons. These are referenced by **SingletonUpdateChange**, **MapChangeKey**, and **MapChangeValue**. SDKs must expose each as a wrapper type; do not expose proto-generated types.

#### Network Configuration State

##### BlockInfo

Network block information singleton. Aligns with `BlockInfo` in services/state/blockrecords/block_info.proto.

```
@@finalType
BlockInfo {
    @@immutable lastBlockNumber: int64
    @@immutable firstConsTimeOfLastBlock: dateTime
    @@immutable blockHashes: bytes
    @@immutable consTimeOfLastHandledTxn: dateTime
    @@immutable migrationRecordsStreamed: bool
    @@immutable firstConsTimeOfCurrentBlock: dateTime
    @@immutable lastUsedConsTime: dateTime
    @@immutable lastIntervalProcessTime: dateTime
}
```

##### CongestionLevelStarts

Congestion pricing level start times. Aligns with `CongestionLevelStarts` in services/state/congestion/congestion_level_starts.proto.

```
@@finalType
CongestionLevelStarts {
    @@immutable genericLevelStarts: list<dateTime>
    @@immutable gasLevelStarts: list<dateTime>
}
```

##### NetworkStakingRewards

Network staking reward state. Aligns with `NetworkStakingRewards` in services/state/token/network_staking_rewards.proto.

```
@@finalType
NetworkStakingRewards {
    @@immutable stakingRewardsActivated: bool
    @@immutable totalStakedRewardStart: int64
    @@immutable totalStakedStart: int64
    @@immutable pendingRewards: int64
}
```

##### NodeRewards

Node rewards singleton. Aligns with `NodeRewards` in services/state/token/node_rewards.proto.

```
@@finalType
NodeRewards {
    @@immutable numRoundsInStakingPeriod: uint64
    @@immutable nodeFeesCollected: uint64
    @@immutable nodeActivities: list<NodeActivity>
}
```

##### NodeActivity

A record of judge rounds missed by a single node. Aligns with `NodeActivity` in services/state/token/node_rewards.proto.

```
@@finalType
NodeActivity {
    // The node identifier
    @@immutable nodeId: uint64

    // The count of rounds in this staking period where the node did not create judges
    @@immutable numMissedJudgeRounds: uint64
}
```

##### NodePayments

Node payments singleton. Aligns with `NodePayments` in services/state/token/node_payments.proto.

```
@@finalType
NodePayments {
    @@immutable lastNodeFeeDistributionTime: dateTime
    @@immutable payments: list<NodePayment>
}
```

##### NodePayment

A record of the total amount of fees due to a node. Aligns with `NodePayment` in services/state/token/node_payments.proto.

```
@@finalType
NodePayment {
    // The node account id
    @@immutable nodeAccountId: AccountId

    // The total amount of fees due to the node in tinybars
    @@immutable fees: uint64
}
```

##### RunningHashes

Running hashes singleton. Aligns with `RunningHashes` in services/state/blockrecords/running_hashes.proto.

```
@@finalType
RunningHashes {
    @@immutable runningHash: bytes
    @@immutable nMinus1RunningHash: bytes
    @@immutable nMinus2RunningHash: bytes
    @@immutable nMinus3RunningHash: bytes
}
```

##### ThrottleUsageSnapshots

Throttle usage snapshot state. Aligns with `ThrottleUsageSnapshots` in services/state/throttles/throttle_usage_snapshots.proto.

```
@@finalType
ThrottleUsageSnapshots {
    @@immutable tpsThrottles: list<ThrottleUsageSnapshot>
    @@immutable @@nullable gasThrottle: ThrottleUsageSnapshot
    @@immutable @@nullable evmOpsDurationThrottle: ThrottleUsageSnapshot
}
```

##### ThrottleUsageSnapshot

A single snapshot of used throttle capacity for a throttle at a point in time. Aligns with `ThrottleUsageSnapshot` in services/state/throttles/throttle_usage_snapshots.proto.

```
@@finalType
ThrottleUsageSnapshot {
    // Used throttle capacity
    @@immutable used: int64

    // The time at which this snapshot of capacity was calculated
    @@immutable lastDecisionTime: dateTime
}
```

##### BlockStreamInfo

Block stream status singleton. Aligns with `BlockStreamInfo` in services/state/blockstream/block_stream_info.proto.

```
@@finalType
BlockStreamInfo {
    @@immutable blockNumber: uint64
    @@immutable blockTime: dateTime
    @@immutable trailingOutputHashes: bytes
    @@immutable trailingBlockHashes: bytes
    @@immutable inputTreeRootHash: bytes
    @@immutable startOfBlockStateHash: bytes
    @@immutable numPrecedingStateChangesItems: uint32
    @@immutable rightmostPrecedingStateChangesTreeHashes: list<bytes>
    @@immutable blockEndTime: dateTime
    @@immutable postUpgradeWorkDone: bool
    @@immutable creationSoftwareVersion: SemanticVersion
    @@immutable lastIntervalProcessTime: dateTime
    @@immutable lastHandleTime: dateTime
    @@immutable consensusHeaderRootHash: bytes
    @@immutable outputItemRootHash: bytes
    @@immutable traceDataRootHash: bytes
    @@immutable intermediatePreviousBlockRootHashes: list<bytes>
    @@immutable intermediateBlockRootsLeafCount: uint64
}
```

##### EntityCounts

Counts of all entities on the network. Aligns with `EntityCounts` in services/state/entity/entity_counts.proto.

```
@@finalType
EntityCounts {
    @@immutable numAccounts: uint64
    @@immutable numAliases: uint64
    @@immutable numTokens: uint64
    @@immutable numTokenRelations: uint64
    @@immutable numNfts: uint64
    @@immutable numAirdrops: uint64
    @@immutable numStakingInfos: uint64
    @@immutable numTopics: uint64
    @@immutable numFiles: uint64
    @@immutable numNodes: uint64
    @@immutable numSchedules: uint64
    @@immutable numContractStorageSlots: uint64
    @@immutable numContractBytecodes: uint64
    @@immutable numHooks: uint64
    @@immutable numEvmHookStorageSlots: uint64
}
```

#### Network Entity State Types

##### Account

A network account. Aligns with `Account` in services/state/token/account.proto.

```
@@finalType
@@oneOf(stakedAccountId, stakedNodeId)
Account {
    @@immutable @@nullable accountId: AccountId
    @@immutable alias: bytes
    @@immutable @@nullable key: Key
    @@immutable expirationSecond: int64
    @@immutable tinybarBalance: int64
    @@immutable memo: string
    @@immutable deleted: bool
    @@immutable stakedToMe: int64
    @@immutable stakePeriodStart: int64
    @@immutable @@nullable stakedAccountId: AccountId
    @@immutable @@nullable stakedNodeId: int64
    @@immutable declineReward: bool
    @@immutable receiverSigRequired: bool
    @@immutable @@nullable headTokenId: TokenId
    @@immutable @@nullable headNftId: NftId
    @@immutable headNftSerialNumber: int64
    @@immutable numberOwnedNfts: int64
    @@immutable maxAutoAssociations: int32
    @@immutable usedAutoAssociations: int32
    @@immutable numberAssociations: int32
    @@immutable smartContract: bool
    @@immutable numberPositiveBalances: int32
    @@immutable ethereumNonce: int64
    @@immutable stakeAtStartOfLastRewardedPeriod: int64
    @@immutable @@nullable autoRenewAccountId: AccountId
    @@immutable autoRenewSeconds: int64
    @@immutable contractKvPairsNumber: int32
    @@immutable numberTreasuryTitles: uint32
    @@immutable expiredAndPendingRemoval: bool
    @@immutable firstContractStorageKey: bytes
    @@immutable @@nullable headPendingAirdropId: PendingAirdropId
    @@immutable numberPendingAirdrops: uint64
    @@immutable numberHooksInUse: uint64
    @@immutable firstHookId: int64
    @@immutable numberEvmHookStorageSlots: uint64
}
```

##### Bytecode

Compiled EVM bytecode for a contract. Aligns with `Bytecode` in services/state/contract/bytecode.proto.

```
@@finalType
Bytecode {
    @@immutable code: bytes
}
```

##### File

A Hedera File Service file. Aligns with `File` in services/state/file/file.proto.

```
@@finalType
File {
    @@immutable @@nullable fileId: FileId
    @@immutable expirationSecond: int64
    @@immutable @@nullable keys: KeyList
    @@immutable contents: bytes
    @@immutable memo: string
    @@immutable deleted: bool
    @@immutable preSystemDeleteExpirationSecond: int64
}
```

##### Nft

A non-fungible/unique token instance. Aligns with `Nft` in services/state/token/nft.proto.

```
@@finalType
Nft {
    @@immutable @@nullable nftId: NftId
    @@immutable @@nullable ownerId: AccountId
    @@immutable @@nullable spenderId: AccountId
    @@immutable mintTime: dateTime
    @@immutable metadata: bytes
    @@immutable @@nullable ownerPreviousNftId: NftId
    @@immutable @@nullable ownerNextNftId: NftId
}
```

##### Schedule

A scheduled transaction. Aligns with `Schedule` in services/state/schedule/schedule.proto.

```
@@finalType
Schedule {
    @@immutable @@nullable scheduleId: ScheduleId
    @@immutable deleted: bool
    @@immutable executed: bool
    @@immutable waitForExpiry: bool
    @@immutable memo: string
    @@immutable @@nullable schedulerAccountId: AccountId
    @@immutable @@nullable payerAccountId: AccountId
    @@immutable @@nullable adminKey: Key
    @@immutable @@nullable scheduleValidStart: dateTime
    @@immutable providedExpirationSecond: int64
    @@immutable calculatedExpirationSecond: int64
    @@immutable @@nullable resolutionTime: dateTime
    @@immutable @@nullable scheduledTransaction: bytes
    @@immutable @@nullable originalCreateTransaction: bytes
    @@immutable signatories: list<Key>
}
```

##### ScheduleList

A list of schedules. Aligns with `ScheduleList` in services/state/schedule/schedule.proto.

```
@@finalType
ScheduleList {
    @@immutable schedules: list<Schedule>
}
```

##### ScheduledCounts

Counts of scheduled and processed transactions within a consensus second. Aligns with `ScheduledCounts` in services/state/schedule/schedule.proto.

```
@@finalType
ScheduledCounts {
    @@immutable numberScheduled: uint32
    @@immutable numberProcessed: uint32
}
```

##### Token

An HTS token definition. Aligns with `Token` in services/state/token/token.proto.

```
@@finalType
Token {
    @@immutable @@nullable tokenId: TokenId
    @@immutable name: string
    @@immutable symbol: string
    @@immutable decimals: int32
    @@immutable totalSupply: int64
    @@immutable @@nullable treasuryAccountId: AccountId
    @@immutable @@nullable adminKey: Key
    @@immutable @@nullable kycKey: Key
    @@immutable @@nullable freezeKey: Key
    @@immutable @@nullable wipeKey: Key
    @@immutable @@nullable supplyKey: Key
    @@immutable @@nullable feeScheduleKey: Key
    @@immutable @@nullable pauseKey: Key
    @@immutable lastUsedSerialNumber: int64
    @@immutable deleted: bool
    @@immutable tokenType: TokenType
    @@immutable supplyType: TokenSupplyType
    @@immutable @@nullable autoRenewAccountId: AccountId
    @@immutable autoRenewSeconds: int64
    @@immutable expirationSecond: int64
    @@immutable memo: string
    @@immutable maxSupply: int64
    @@immutable paused: bool
    @@immutable accountsFrozenByDefault: bool
    @@immutable accountsKycGrantedByDefault: bool
    @@immutable metadata: bytes
    @@immutable @@nullable metadataKey: Key
}
```

##### TokenRelation

A token-to-account relationship. Aligns with `TokenRelation` in services/state/token/token_relation.proto.

```
@@finalType
TokenRelation {
    @@immutable @@nullable tokenId: TokenId
    @@immutable @@nullable accountId: AccountId
    @@immutable balance: int64
    @@immutable frozen: bool
    @@immutable kycGranted: bool
    @@immutable automaticAssociation: bool
    @@immutable @@nullable previousToken: TokenId
    @@immutable @@nullable nextToken: TokenId
}
```

##### Topic

An HCS topic. Aligns with `Topic` in services/state/consensus/topic.proto.

```
@@finalType
Topic {
    @@immutable @@nullable topicId: TopicId
    @@immutable sequenceNumber: int64
    @@immutable expirationSecond: int64
    @@immutable autoRenewPeriod: int64
    @@immutable @@nullable autoRenewAccountId: AccountId
    @@immutable deleted: bool
    @@immutable runningHash: bytes
    @@immutable memo: string
    @@immutable @@nullable adminKey: Key
    @@immutable @@nullable submitKey: Key
    @@immutable @@nullable feeScheduleKey: Key
}
```

##### Node

A network address book node. Aligns with `Node` in services/state/addressbook/node.proto.

```
@@finalType
Node {
    @@immutable nodeId: uint64
    @@immutable @@nullable accountId: AccountId
    @@immutable description: string
    @@immutable deleted: bool
    @@immutable @@nullable adminKey: Key
    @@immutable declineReward: bool
    @@immutable gossipEndpoint: list<ServiceEndpoint>
    @@immutable serviceEndpoint: list<ServiceEndpoint>
    @@immutable gossipCaCertificate: bytes
    @@immutable grpcCertificateHash: bytes
    @@immutable @@nullable grpcProxyEndpoint: ServiceEndpoint
}
```

##### StakingNodeInfo

Staking information for a node. Aligns with `StakingNodeInfo` in services/state/token/staking_node_info.proto.

```
@@finalType
StakingNodeInfo {
    @@immutable nodeNumber: int64
    @@immutable minStake: int64
    @@immutable maxStake: int64
    @@immutable stakeToReward: int64
    @@immutable stakeToNotReward: int64
    @@immutable stakeRewardStart: int64
    @@immutable unclaimedStakeRewardStart: int64
    @@immutable stake: int64
    @@immutable rewardSumHistory: list<int64>
    @@immutable pendingRewards: int64
    @@immutable deleted: bool
}
```

##### AccountPendingAirdrop

A pending airdrop entry. Aligns with `AccountPendingAirdrop` in services/state/token/account_pending_airdrop.proto.

```
@@finalType
AccountPendingAirdrop {
    @@immutable @@nullable pendingAirdropValue: bytes
    @@immutable @@nullable previousAirdrop: PendingAirdropId
    @@immutable @@nullable nextAirdrop: PendingAirdropId
}
```

#### Platform & Consensus State Types

##### PlatformState

Platform consensus state singleton. Aligns with `PlatformState` in platform/state/platform_state.proto.

```
@@finalType
PlatformState {
    @@immutable creationSoftwareVersion: SemanticVersion
    @@immutable roundsNonAncient: uint32
    @@immutable @@nullable consensusSnapshot: ConsensusSnapshot
    @@immutable @@nullable freezeTime: dateTime
    @@immutable @@nullable lastFrozenTime: dateTime
    @@immutable latestFreezeRound: uint64
}
```

##### ConsensusSnapshot

A snapshot of the consensus state for a particular round. Aligns with `ConsensusSnapshot` in platform/state/platform_state.proto.

```
@@finalType
ConsensusSnapshot {
    // The round number of this snapshot
    @@immutable round: uint64

    // Minimum ancient entries for non-ancient rounds
    @@immutable minimumJudgeInfoList: list<MinimumJudgeInfo>

    // The consensus order of the next event to reach consensus
    @@immutable nextConsensusNumber: uint64

    // The consensus timestamp of this snapshot
    @@immutable consensusTimestamp: dateTime

    // A list of judge creator ids and hashes in a round
    @@immutable judgeIds: list<JudgeId>
}
```

##### MinimumJudgeInfo

Minimum ancient indicator for all judges in a particular round. Aligns with `MinimumJudgeInfo` in platform/state/platform_state.proto.

```
@@finalType
MinimumJudgeInfo {
    // The round this judge information applies to
    @@immutable round: uint64

    // Minimum birth round for all judges for a given round
    @@immutable minimumJudgeBirthRound: uint64
}
```

##### JudgeId

A judge information including creator node ID and hash. Aligns with `JudgeId` in platform/state/platform_state.proto.

```
@@finalType
JudgeId {
    // The creator node ID who created this judge
    @@immutable creatorId: uint64

    // SHA-384 hash value of this judge
    @@immutable judgeHash: bytes
}
```

##### Roster

A network roster (list of participating nodes). Aligns with `Roster` in services/state/roster/roster.proto.

```
@@finalType
Roster {
    @@immutable rosterEntries: list<RosterEntry>
}
```

##### RosterEntry

A single roster entry for a consensus node. Aligns with `RosterEntry` in services/state/roster/roster.proto.

```
@@finalType
RosterEntry {
    // A consensus node identifier
    @@immutable nodeId: uint64

    // A consensus weight
    @@immutable weight: uint64

    // An RSA public certificate used for signing gossip events (DER encoding)
    @@immutable gossipCaCertificate: bytes

    // A list of service endpoints for gossip
    @@immutable gossipEndpoint: list<ServiceEndpoint>
}
```

##### RosterState

Roster management state singleton. Aligns with `RosterState` in services/state/roster/roster_state.proto.

```
@@finalType
RosterState {
    @@immutable candidateRosterHash: bytes
    @@immutable roundRosterPairs: list<bytes>
    @@immutable transplantInProgress: bool
}
```

Note: Each entry in `roundRosterPairs` is a serialized `RoundRosterPair` proto. SDKs may expose as raw bytes or define a wrapper.

#### Contract & Hook State Types

##### SlotKey

An EVM contract storage slot key. Aligns with `SlotKey` in services/state/contract/storage_slot.proto.

```
@@finalType
SlotKey {
    @@immutable contractId: ContractId
    @@immutable key: bytes
}
```

##### SlotValue

An EVM contract storage slot value. Aligns with `SlotValue` in services/state/contract/storage_slot.proto.

```
@@finalType
SlotValue {
    @@immutable value: bytes
    @@immutable previousKey: bytes
    @@immutable nextKey: bytes
}
```

##### EvmHookState

State for an EVM hook. Aligns with `EvmHookState` in services/state/contract/evm_hook_state.proto.

```
@@finalType
EvmHookState {
    @@immutable @@nullable hookId: HookId
    @@immutable hookType: int32
    @@immutable extensionPoint: int32
    @@immutable @@nullable hookContractId: ContractId
    @@immutable @@nullable adminKey: Key
    @@immutable firstContractStorageKey: bytes
    @@immutable @@nullable previousHookId: int64
    @@immutable @@nullable nextHookId: int64
    @@immutable numStorageSlots: uint32
}
```

##### EvmHookSlotKey

Key for an EVM hook storage slot. Aligns with `EvmHookSlotKey` in services/state/contract/evm_hook_state.proto.

```
@@finalType
EvmHookSlotKey {
    @@immutable hookId: HookId
    @@immutable key: bytes
}
```

#### Schedule State Types

##### ScheduledOrder

An ordering key for long-term scheduled transactions. Aligns with `ScheduledOrder` in services/state/schedule/schedule.proto.

```
@@finalType
ScheduledOrder {
    @@immutable expirySecond: uint64
    @@immutable orderNumber: uint32
}
```

##### TimestampSeconds

A timestamp with one-second resolution. Aligns with `TimestampSeconds` in services/timestamp.proto.

```
@@finalType
TimestampSeconds {
    @@immutable seconds: int64
}
```

#### TSS State Types

##### TssMessageMapKey

Key for TSS message map entries. Aligns with `TssMessageMapKey` in services/state/tss/tss_message_map_key.proto.

```
@@finalType
TssMessageMapKey {
    @@immutable rosterHash: bytes
    @@immutable sequenceNumber: uint64
}
```

##### TssVoteMapKey

Key for TSS vote map entries. Aligns with `TssVoteMapKey` in services/state/tss/tss_vote_map_key.proto.

```
@@finalType
TssVoteMapKey {
    @@immutable rosterHash: bytes
    @@immutable nodeId: uint64
}
```

##### TssEncryptionKeys

TSS encryption keys for a node. Aligns with `TssEncryptionKeys` in services/state/tss/tss_encryption_keys.proto.

```
@@finalType
TssEncryptionKeys {
    @@immutable currentEncryptionKey: bytes
    @@immutable nextEncryptionKey: bytes
}
```

##### TssMessageTransactionBody

A TSS message submission. Aligns with `TssMessageTransactionBody` in services/auxiliary/tss/tss_message.proto.

```
@@finalType
TssMessageTransactionBody {
    @@immutable sourceRosterHash: bytes
    @@immutable targetRosterHash: bytes
    @@immutable shareIndex: uint64
    @@immutable tssMessage: bytes
}
```

##### TssVoteTransactionBody

A TSS vote submission. Aligns with `TssVoteTransactionBody` in services/auxiliary/tss/tss_vote.proto.

```
@@finalType
TssVoteTransactionBody {
    @@immutable sourceRosterHash: bytes
    @@immutable targetRosterHash: bytes
    @@immutable ledgerId: bytes
    @@immutable nodeSignature: bytes
    @@immutable tssVote: bytes
}
```

#### hinTS State Types

##### HintsPartyId

A hinTS party identifier. Aligns with `HintsPartyId` in services/state/hints/hints_types.proto.

```
@@finalType
HintsPartyId {
    @@immutable partyId: uint32
    @@immutable numParties: uint32
}
```

##### PreprocessingVoteId

Identifier for a hinTS preprocessing vote. Aligns with `PreprocessingVoteId` in services/state/hints/hints_types.proto.

```
@@finalType
PreprocessingVoteId {
    @@immutable constructionId: uint64
    @@immutable nodeId: uint64
}
```

##### HintsKeySet

A hinTS key set for a node. Aligns with `HintsKeySet` in services/state/hints/hints_types.proto.

```
@@finalType
HintsKeySet {
    @@immutable nodeId: uint64
    @@immutable adoptionTime: dateTime
    @@immutable key: bytes
    @@immutable nextKey: bytes
}
```

##### PreprocessedKeys

The output of the hinTS preprocessing algorithm. Aligns with `PreprocessedKeys` in services/state/hints/hints_types.proto.

```
@@finalType
PreprocessedKeys {
    // The aggregation key for the hinTS scheme
    @@immutable aggregationKey: bytes

    // The succinct verification key for the hinTS scheme
    @@immutable verificationKey: bytes
}
```

##### NodePartyId

A node's weighted hinTS party id. Aligns with `NodePartyId` in services/state/hints/hints_types.proto.

```
@@finalType
NodePartyId {
    // The node id
    @@immutable nodeId: uint64

    // The party id
    @@immutable partyId: uint32

    // The party's weight in the construction
    @@immutable partyWeight: uint64
}
```

##### HintsScheme

The information constituting the hinTS scheme. Aligns with `HintsScheme` in services/state/hints/hints_types.proto.

```
@@finalType
HintsScheme {
    // The aggregation and verification keys for the scheme
    @@immutable preprocessedKeys: PreprocessedKeys

    // The final party ids assigned to each node in the target roster
    @@immutable nodePartyIds: list<NodePartyId>
}
```

##### PreprocessingVote

A hinTS preprocessing vote. Aligns with `PreprocessingVote` in services/state/hints/hints_types.proto.

```
@@finalType
@@oneOf(preprocessedKeys, congruentNodeId)
PreprocessingVote {
    @@immutable @@nullable preprocessedKeys: PreprocessedKeys
    @@immutable @@nullable congruentNodeId: uint64
}
```

##### HintsConstruction

A hinTS construction state singleton. Aligns with `HintsConstruction` in services/state/hints/hints_types.proto.

```
@@finalType
@@oneOf(gracePeriodEndTime, preprocessingStartTime, hintsScheme)
HintsConstruction {
    @@immutable constructionId: uint64
    @@immutable sourceRosterHash: bytes
    @@immutable targetRosterHash: bytes
    @@immutable @@nullable gracePeriodEndTime: dateTime
    @@immutable @@nullable preprocessingStartTime: dateTime
    @@immutable @@nullable hintsScheme: HintsScheme
}
```

##### CRSStage

Stage of the CRS (Common Reference String) ceremony.

```
enum CRSStage {
    GATHERING_CONTRIBUTIONS
    WAITING_FOR_ADOPTING_FINAL_CRS
    COMPLETED
}
```

##### CRSState

CRS (Common Reference String) state singleton. Aligns with `CRSState` in services/state/hints/hints_types.proto.

```
@@finalType
CRSState {
    @@immutable crs: bytes
    @@immutable stage: CRSStage
    @@immutable @@nullable nextContributingNodeId: uint64
    @@immutable @@nullable contributionEndTime: dateTime
}
```

##### CrsPublicationTransactionBody

A CRS publication transaction body. Aligns with `CrsPublicationTransactionBody` in services/auxiliary/hints/crs_publication.proto.

```
@@finalType
CrsPublicationTransactionBody {
    @@immutable newCrs: bytes
    @@immutable proof: bytes
}
```

#### History Proof State Types

##### ConstructionNodeId

A construction-scoped node identifier (used in history proof and hinTS contexts). Aligns with `ConstructionNodeId` in services/state/history/history_types.proto.

```
@@finalType
ConstructionNodeId {
    @@immutable constructionId: uint64
    @@immutable nodeId: uint64
}
```

##### ProofKeySet

A proof key set for a node. Aligns with `ProofKeySet` in services/state/history/history_types.proto.

```
@@finalType
ProofKeySet {
    @@immutable adoptionTime: dateTime
    @@immutable key: bytes
    @@immutable nextKey: bytes
}
```

##### ProofKey

A record of the proof key a node had in a particular address book. Aligns with `ProofKey` in services/state/history/history_types.proto.

```
@@finalType
ProofKey {
    // The node id
    @@immutable nodeId: uint64

    // The key
    @@immutable key: bytes
}
```

##### History

A piece of new history in the form of an address book hash and associated metadata. Aligns with `History` in services/state/history/history_types.proto.

```
@@finalType
History {
    // The address book hash of the new history
    @@immutable addressBookHash: bytes

    // The metadata associated to the address book
    @@immutable metadata: bytes
}
```

##### HistoryProof

A proof that some address book history belongs to the ledger id's chain of trust. Aligns with `HistoryProof` in services/state/history/history_types.proto.

```
@@finalType
HistoryProof {
    // The proof keys for the target address book
    @@immutable targetProofKeys: list<ProofKey>

    // The target history of the proof
    @@immutable targetHistory: History

    // The proof of chain of trust from the ledger id to the target history's metadata
    @@immutable chainOfTrustProof: ChainOfTrustProof

    // If set, the uncompressed proof of chain of trust
    @@immutable @@nullable uncompressedWrapsProof: bytes
}
```

##### HistorySignature

A node's signature blessing some new history. Aligns with `HistorySignature` in services/state/history/history_types.proto.

```
@@finalType
HistorySignature {
    // The new history the node is signing
    @@immutable history: History

    // The node's signature on the canonical serialization of the new history
    @@immutable signature: bytes
}
```

##### RecordedHistorySignature

A recorded history signature. Aligns with `RecordedHistorySignature` in services/state/history/history_types.proto.

```
@@finalType
RecordedHistorySignature {
    @@immutable signingTime: dateTime
    @@immutable historySignature: HistorySignature
}
```

##### HistoryProofVote

A vote on a history proof. Aligns with `HistoryProofVote` in services/state/history/history_types.proto.

```
@@finalType
@@oneOf(proof, congruentNodeId)
HistoryProofVote {
    @@immutable @@nullable proof: HistoryProof
    @@immutable @@nullable congruentNodeId: uint64
}
```

##### WrapsPhase

The phase of a WRAPS proof construction. Aligns with `WrapsPhase` in services/state/history/history_types.proto.

```
enum WrapsPhase {
    R1
    R2
    R3
    AGGREGATE
}
```

##### WrapsSigningState

The state of an ongoing WRAPS signature protocol. Aligns with `WrapsSigningState` in services/state/history/history_types.proto.

```
@@finalType
WrapsSigningState {
    // The phase of the WRAPS protocol
    @@immutable phase: WrapsPhase

    // Grace period end time for gathering WRAPS messages
    @@immutable @@nullable gracePeriodEndTime: dateTime
}
```

##### HistoryProofConstruction

A history proof construction state singleton. Aligns with `HistoryProofConstruction` in services/state/history/history_types.proto.

```
@@finalType
@@oneOf(gracePeriodEndTime, assemblyStartTime, targetProof, failureReason, wrapsSigningState)
HistoryProofConstruction {
    @@immutable constructionId: uint64
    @@immutable sourceRosterHash: bytes
    @@immutable targetRosterHash: bytes
    @@immutable @@nullable gracePeriodEndTime: dateTime
    @@immutable @@nullable assemblyStartTime: dateTime
    @@immutable @@nullable targetProof: HistoryProof
    @@immutable @@nullable failureReason: string
    @@immutable @@nullable wrapsSigningState: WrapsSigningState
}
```

##### WrapsMessageDetails

A message published by a node during a WRAPS proof construction. Aligns with `WrapsMessageDetails` in services/state/history/history_types.proto.

```
@@finalType
WrapsMessageDetails {
    // The time at which the message was published
    @@immutable publicationTime: dateTime

    // The phase of the construction the message applies to
    @@immutable phase: WrapsPhase

    // The message itself
    @@immutable message: bytes
}
```

##### WrapsMessageHistory

A history of messages published during a WRAPS proof construction. Aligns with `WrapsMessageHistory` in services/state/history/history_types.proto.

```
@@finalType
WrapsMessageHistory {
    @@immutable messages: list<WrapsMessageDetails>
}
```

---

### namespace proofs

requires blockStream, state

Types for block proof verification: merkle tree components, signature types, and proof containers.

#### SiblingNode

Represents a sibling node hash in a MerklePath.

```
@@finalType
SiblingNode {
    // True when this sibling is on the left of the merkle path
    @@immutable isLeft: bool

    // The hash of the sibling node
    @@immutable hash: bytes
}
```

#### MerkleLeaf

A leaf node in a block merkle tree. Exactly one of **blockConsensusTimestamp**, **blockItem**, or **stateItem** is set. Aligns with `MerkleLeaf` in services/state/blockstream/merkle_leaf.proto.

```
@@finalType
@@oneOf(blockConsensusTimestamp, blockItem, stateItem)
MerkleLeaf {
    // Consensus timestamp of the first round in the current block (first transaction in that round)
    @@immutable @@nullable blockConsensusTimestamp: bytes

    // Serialized bytes of a single BlockItem message
    @@immutable @@nullable blockItem: bytes

    // Serialized bytes of a single StateItem message
    @@immutable @@nullable stateItem: bytes
}
```

#### MerklePath

A path from a node in a Merkle tree to the root of that tree.

```
@@finalType
@@oneOf(leaf, hash)
MerklePath {
    // Optional leaf, if this path starts from a leaf
    @@immutable @@nullable leaf: MerkleLeaf

    // Optional hash for a path with no leaf
    @@immutable @@nullable hash: bytes

    // Array of sibling nodes ordered from bottom of tree to top
    @@immutable siblings: list<SiblingNode>

    // Index of next parent path going up the tree (UINT32_MAX if root)
    @@immutable nextPathIndex: uint32
}
```

Note: **MerkleLeaf** is defined above; SDKs must expose it as a wrapper type.

#### RecordFileSignature

A signature by a node on the SHA384 hash of a record file.

```
@@finalType
RecordFileSignature {
    // RSA signature (DER-encoded X.509) of the node on the SHA384 hash of the record file
    @@immutable signaturesBytes: bytes

    // Node id of the consensus node that created this signature
    @@immutable nodeId: int32
}
```

#### AggregatedNodeSignatures

An aggregation of node signatures on some data.

```
@@finalType
AggregatedNodeSignatures {
    // The aggregated signature
    @@immutable aggregatedSignature: bytes

    // In ascending order, the ids of the nodes that contributed signatures
    @@immutable signingNodeIds: list<uint64>

    // The hinTS verification key being witnessed by these aggregated signatures
    @@immutable verificationKey: bytes
}
```

#### TssSignedBlockProof

A proof containing a TSS signature for a single block.

```
@@finalType
TssSignedBlockProof {
    // TSS signature for one block (aggregated from nodes with >2/3 network weight)
    @@immutable blockSignature: bytes
}
```

#### SignedRecordFileProof

A proof containing RSA signatures from consensus nodes for a record file (backward compatibility).

```
@@finalType
SignedRecordFileProof {
    // Record file format version (2, 5, or 6)
    @@immutable version: uint32

    // Collection of RSA signatures from consensus nodes
    @@immutable recordFileSignatures: list<RecordFileSignature>
}
```

#### ChainOfTrustProof

Proof that a verification key belongs to the network's chain of trust.

```
@@finalType
@@oneOf(aggregatedNodeSignatures, wrapsProof)
ChainOfTrustProof {
    // Aggregation of Schnorr signatures (used until first recursive proof is available)
    @@immutable @@nullable aggregatedNodeSignatures: AggregatedNodeSignatures

    // ZK-compressed SNARK proof proving the chain of trust
    @@immutable @@nullable wrapsProof: bytes
}
```

#### StateProof

A state proof that cryptographically proves nodes in the block merkle tree.

```
@@finalType
@@oneOf(signedBlockProof)
StateProof {
    // Merkle paths that prove the nodes in the block merkle tree
    @@immutable paths: list<MerklePath>

    // TSS signature proof for the block (present when proof is for a block with block number >= current block)
    @@immutable @@nullable signedBlockProof: TssSignedBlockProof
}
```

#### BlockProof

Cryptographic proof for the Block Merkle Tree.

```
@@finalType
@@oneOf(signedBlockProof, blockStateProof, signedRecordFileProof, aggregatedNodeSignatures)
BlockProof {
    // The block number this proof secures
    @@immutable block: uint64

    // TSS signature over the block's merkle root hash (oneof proof)
    @@immutable @@nullable signedBlockProof: TssSignedBlockProof

    // Proof of the block merkle tree's contents (oneof proof)
    @@immutable @@nullable blockStateProof: StateProof

    // RSA signatures from consensus nodes for backward compatibility (oneof proof)
    @@immutable @@nullable signedRecordFileProof: SignedRecordFileProof

    // Aggregated Schnorr signatures from consensus nodes (oneof proof)
    @@immutable @@nullable aggregatedNodeSignatures: AggregatedNodeSignatures
}
```

Note: The `ChainOfTrustProof`, `verificationKey`, and sibling hash fields are part of the broader proof verification flow but are not fields of the `BlockProof` message itself. Obtaining a trusted block merkle root (e.g. for verification) typically requires verifying the **BlockProof** for that block. SDKs may provide a way to verify a **BlockProof** and obtain the block merkle root.

---

### namespace legacy

requires blockStream

Types for legacy record stream data (pre-block stream format). These are only used when a **BlockItem** contains a **RecordFileItem** (blocks that wrap historical record files).

#### SidecarFile

A sidecar file containing transaction sidecar records (state changes, actions, bytecode) for the same period as a RecordStreamFile. Aligns with `SidecarFile` in streams/sidecar_file.proto.

```
@@finalType
SidecarFile {
    @@immutable sidecarRecords: list<TransactionSidecarRecord>
}
```

##### TransactionSidecarRecord

A single sidecar record complementing a transaction record. Aligns with `TransactionSidecarRecord` in streams/sidecar_file.proto.

```
@@finalType
TransactionSidecarRecord {
    // Same consensus timestamp as the transaction this sidecar relates to
    @@immutable consensusTimestamp: dateTime

    // True if this sidecar is from migration
    @@immutable migration: bool

    // Exactly one of: stateChanges (ContractStateChanges), actions (ContractActions), bytecode (ContractBytecode)
    @@oneOf(stateChanges, actions, bytecode)
    @@immutable @@nullable stateChanges: ContractStateChanges
    @@immutable @@nullable actions: ContractActions
    @@immutable @@nullable bytecode: ContractBytecode
}
```

##### ContractStateChanges

A collection of contract storage state changes from a sidecar record. Aligns with `ContractStateChanges` in streams/contract_state_change.proto.

```
@@finalType
ContractStateChanges {
    @@immutable contractStateChanges: list<ContractStateChange>
}
```

##### ContractStateChange

Storage changes to a single smart contract as a side effect of a function call. Aligns with `ContractStateChange` in streams/contract_state_change.proto.

```
@@finalType
ContractStateChange {
    // The contract to which the storage changes apply
    @@immutable contractId: ContractId

    // The list of storage changes
    @@immutable storageChanges: list<StorageChange>
}
```

##### StorageChange

A single storage slot change. Aligns with `StorageChange` in streams/contract_state_change.proto.

```
@@finalType
StorageChange {
    // The storage slot changed (up to 32 bytes, big-endian, zero bytes left trimmed)
    @@immutable slot: bytes

    // The value read from the storage slot (up to 32 bytes, big-endian, zero bytes left trimmed)
    @@immutable valueRead: bytes

    // The new value written to the slot; null if the slot was only read and not written
    @@immutable @@nullable valueWritten: bytes
}
```

##### ContractActions

A collection of contract actions from a sidecar record. Aligns with `ContractActions` in streams/contract_action.proto. Reuses the same **ContractAction** type defined in the `blockStream` namespace under EVM trace data.

```
@@finalType
ContractActions {
    @@immutable contractActions: list<ContractAction>
}
```

##### ContractBytecode

Contract bytecode from a sidecar record (deployment and runtime). Aligns with `ContractBytecode` in streams/contract_bytecode.proto.

```
@@finalType
ContractBytecode {
    // The contract to which the bytecodes apply
    @@immutable contractId: ContractId

    // Contract bytecode during deployment
    @@immutable initcode: bytes

    // Contract bytecode after deployment
    @@immutable runtimeBytecode: bytes
}
```

#### RecordFileItem

A block item containing data from the legacy record stream format (pre-block stream).

```
@@finalType
RecordFileItem {
    // The consensus time the record file was produced for
    @@immutable creationTime: dateTime

    // The contents of a record file (V6 RecordStreamFile message)
    @@immutable recordFileContents: RecordStreamFile

    // The contents of sidecar files for this block (zero or more)
    @@immutable sidecarFileContents: list<SidecarFile>
}
```

##### RecordStreamFile

A legacy record stream file containing transaction records for a single block period. Aligns with `RecordStreamFile` in streams/record_stream_file.proto.

```
@@finalType
RecordStreamFile {
    // Version of HAPI used to serialize the file
    @@immutable hapiProtoVersion: SemanticVersion

    // Running hash of all record stream items before this file
    @@immutable startObjectRunningHash: HashObject

    // List of all record stream items from this period
    @@immutable recordStreamItems: list<RecordStreamItem>

    // Running hash of all record stream items at the end of this file
    @@immutable endObjectRunningHash: HashObject

    // The block number associated with this period
    @@immutable blockNumber: int64

    // Hashes of sidecar files created for the same period
    @@immutable sidecars: list<SidecarMetadata>
}
```

##### RecordStreamItem

A single record stream item consisting of a transaction and its record. Aligns with `RecordStreamItem` in streams/record_stream_file.proto.

```
@@finalType
RecordStreamItem {
    // The transaction (use existing SDK Transaction wrapper type)
    @@immutable transaction: Transaction

    // The transaction record (use existing SDK TransactionRecord wrapper type)
    @@immutable record: TransactionRecord
}
```

Note: **Transaction** and **TransactionRecord** are existing SDK wrapper types. SDKs must deserialize the proto bytes into these wrappers when constructing **RecordStreamItem**.

##### HashObject

A hash value with algorithm metadata. Aligns with `HashObject` in streams/hash_object.proto.

```
@@finalType
HashObject {
    // The hashing algorithm used
    @@immutable algorithm: HashAlgorithm

    // Hash length in bytes
    @@immutable length: int32

    // The hash bytes
    @@immutable hash: bytes
}
```

```
enum HashAlgorithm {
    HASH_ALGORITHM_UNKNOWN
    SHA_384
}
```

##### SidecarMetadata

Metadata for a single sidecar record file. Aligns with `SidecarMetadata` in streams/record_stream_file.proto.

```
@@finalType
SidecarMetadata {
    // The hash of the entire sidecar file
    @@immutable hash: HashObject

    // The id of the sidecar record file
    @@immutable id: int32

    // The types of sidecar records in the file
    @@immutable types: list<SidecarType>
}
```

```
enum SidecarType {
    SIDECAR_TYPE_UNKNOWN
    CONTRACT_STATE_CHANGE
    CONTRACT_ACTION
    CONTRACT_BYTECODE
}
```

---

## Updated APIs

### Client

The existing `Client` class is extended with Block Node network management, following the same pattern used for Mirror Network configuration.

```
Client {
    // Get the Block Node network addresses
    list<string> getBlockNodeNetwork()

    // Set the Block Node network addresses (each address in "host:port" form)
    Client setBlockNodeNetwork(addresses: list<string>)
}
```

---

## Internal Changes

### SubscribeStreamResponseCode

Response codes for block stream subscriptions. This enum is **internal** to the SDK and is not part of the public API. SDKs use these codes internally in the `subscribe` method to drive retry logic and error reporting; errors surfaced to the application via the error handler should include the code value in the error message for diagnostic purposes.

```
enum SubscribeStreamResponseCode {
    UNKNOWN
    SUCCESS
    INVALID_REQUEST
    ERROR
    INVALID_START_BLOCK_NUMBER
    INVALID_END_BLOCK_NUMBER
    NOT_AVAILABLE
}
```

### Query Implementation

Block Node request/response queries (**ServerStatusQuery**, **BlockQuery**) extend the SDK's existing `Executable` base type, inheriting **setGrpcDeadline**, **setMaxAttempts**, **setMaxBackoff**, and **execute**. Internally, these queries execute against the client's Block Node network (not the consensus network). SDKs should implement connection management, retry handling, and error mapping following their language's idiomatic patterns.

**Payment exclusion:** Block Node queries do **not** require query payment. Unlike consensus node queries that extend `Query` (which includes payment logic such as `setQueryPayment`, `setMaxQueryPayment`, and automatic cost estimation), Block Node queries extend `Executable` directly and must not include any payment-related methods or behavior. SDKs must ensure that Block Node query types do not inherit or expose payment logic.

Note: **BlockStreamQuery** must extend **StreamQuery&lt;Block&gt;** (not `Executable` directly). Common subscription and handler behavior is implemented in **StreamQuery** only.

### Block Stream Subscription Behavior

**How the gRPC stream works:** The client (SDK) opens a single connection by calling the Block Node `subscribeBlockStream` RPC. Over that connection the server sends a **stream of SubscribeStreamResponse messages**—many such messages over the lifetime of the stream. Each **SubscribeStreamResponse** is one of: **BlockItemSet** (one or more `BlockItem`s for the current block), **BlockEnd** (signals the end of the block, carrying the block number), or a terminal **status** code. A single block may be delivered in one or more **BlockItemSet** messages; the server sends exactly one **BlockEnd** per block.

**What onNext receives:** The SDK (not the application) consumes these **SubscribeStreamResponse** messages. The SDK buffers **BlockItemSet** and **BlockEnd** until it has a complete block, then constructs a **Block** and invokes the application's **onNext** callback with that **Block**. So **onNext** is called with **Block** only—one invocation per completed block. The application never sees raw **SubscribeStreamResponse**, **BlockItemSet**, or **BlockEnd**; the SDK hides the streaming protocol and delivers assembled blocks. This keeps the API simple and ensures the callback is invoked once per completed block.

**Comparison with TopicMessageQuery:** The flow is the same as **TopicMessageQuery**: the client opens one gRPC (or equivalent) stream connection; the server sends many low-level messages over that connection; the SDK consumes those messages and invokes the application's **onNext** once per logical item. For TopicMessageQuery the logical item is one topic message; for BlockStreamQuery it is one assembled **Block**. In both cases the application subscribes with a callback, receives a **SubscriptionHandle**, and never sees the raw stream messages.

**Stream failures and response codes:** When the stream ends with a terminal status other than SUCCESS (e.g. INVALID_START_BLOCK_NUMBER, NOT_AVAILABLE), the SDK reports failure via the **error handler** (inherited from **StreamQuery**) or by throwing; the **SubscriptionHandle** does not expose the status. The error must describe the reason (e.g. invalid block range, stream not available) so the application or the **setRetryHandler** can react. The stream status code (**SubscribeStreamResponseCode**) is an internal/protocol detail: SDKs map it to the errors in the [Error Handling](#error-handling) table (e.g. `invalid-block-range`) and should include the code in the error message for diagnostic purposes, but **SubscribeStreamResponseCode** is not part of the public API.

### Block Node Network Management

The SDK manages Block Node connections similarly to how it manages Mirror Network connections:

1. **Connection Management**: Internal component managing gRPC channels to Block Nodes.

2. **Health Tracking**: Failed Block Node connections are tracked and temporarily removed from the pool, similar to consensus node health tracking.

3. **Channel Reuse**: Reuse existing gRPC channel infrastructure from the SDK.

### Query Execution

Block Node queries follow a pattern similar to the existing Mirror Node query pattern:

1. Queries execute against the client's Block Node network
2. If no Block Node network is configured, queries throw a descriptive error
3. Retry logic follows the same exponential backoff pattern as other queries
4. Request/response queries (**ServerStatusQuery**, **BlockQuery**) extend the SDK's `Executable` type and use `execute(client)`. Streaming queries (**BlockStreamQuery**) extend **StreamQuery**, which extends the SDK's `Executable` type. They implement **subscribe(client, onNext)** (invokes the callback for each item, returns a **SubscriptionHandle** with **unsubscribe()**), **setCompletionHandler**, **setErrorHandler**, and **setRetryHandler**; **setGrpcDeadline**, **setMaxAttempts**, and **setMaxBackoff** are inherited from `Executable`. There is no **execute** method on stream queries; callers subscribe and collect items in the callback until the stream ends or they unsubscribe.

### Error Handling

Protocol-level outcomes (NOT_FOUND, NOT_AVAILABLE, etc.) are carried in the **response object's code** so the SDK and caller can configure retry. The following error cases apply to **transport/gRPC failures** and to **streaming** (where the error handler receives an error); SDKs may also **throw** an error that carries the same code for callers who prefer exception-based handling.

| Error | Description |
|-------|-------------|
| `block-node-network-not-configured` | Block Node query attempted without configuring Block Node network |
| `block-node-grpc-status` | gRPC/transport error from Block Node (includes status code) |
| `invalid-request` | Server returned INVALID_REQUEST (malformed or structurally incorrect request); when returned on response object, **code** is INVALID_REQUEST |
| `block-not-found` | Response **code** NOT_FOUND (block does not exist); payload null |
| `block-not-available` | Response **code** NOT_AVAILABLE (block not on this node); payload null |
| `invalid-block-range` | Invalid block range, e.g. end before start (INVALID_START_BLOCK_NUMBER, INVALID_END_BLOCK_NUMBER); reported in stream or on response |

### Response Codes

The following response codes match the enumerations defined in the hiero-block-node protos (`BlockStreamSubscribeService`, `BlockAccessService`). SDKs map these to the errors in the table above.

**Subscribe Stream Response Codes:**
- `UNKNOWN` - Server software failed to set a status
- `SUCCESS` - Request succeeded
- `INVALID_REQUEST` - Malformed or structurally incorrect request
- `ERROR` - Block Node encountered an error
- `INVALID_START_BLOCK_NUMBER` - Requested start block is not valid
- `INVALID_END_BLOCK_NUMBER` - Requested end block is not valid
- `NOT_AVAILABLE` - Requested stream is not available

**Block Access Response Codes:**
- `UNKNOWN` - Server software failed to set a status
- `SUCCESS` - Request succeeded
- `INVALID_REQUEST` - Malformed request
- `ERROR` - Block Node encountered an error
- `NOT_FOUND` - Block does not exist
- `NOT_AVAILABLE` - Block not currently available on this node

#### Transaction Retry

Block Node APIs do not directly involve transaction submission. However, SDKs should implement retry logic for:
- `ERROR` - Retry with exponential backoff
- `NOT_AVAILABLE` - Retry after short delay or rotate to another Block Node
- gRPC `UNAVAILABLE`, `RESOURCE_EXHAUSTED` - Retry with exponential backoff

---

## Test Plan

### Client Block Node Configuration

1. **Given** a `Client` instance, **when** `setBlockNodeNetwork()` is called with valid addresses, **then** the Block Node network is configured and subsequent Block Node queries succeed.

2. **Given** a `Client` instance with no Block Node network configured, **when** a Block Node query is executed, **then** an error indicating "Block Node network not configured" is thrown.

3. **Given** a `Client` with Block Node network configured, **when** `getBlockNodeNetwork()` is called, **then** the configured addresses are returned.

### ServerStatusQuery

4. **Given** a `Client` with Block Node network configured, **when** `ServerStatusQuery().execute(client)` is called, **then** a `ServerStatus` is returned containing `firstAvailableBlock`, `lastAvailableBlock`, `onlyLatestState`, and `versionInformation`.

5. **Given** a `Client` connected to an unreachable Block Node, **when** `ServerStatusQuery().execute(client)` is called, **then** an error is thrown after retry attempts are exhausted.

### BlockQuery

6. **Given** a valid block number within the node's available range, **when** `BlockQuery().setBlockNumber(n).execute(client)` is called, **then** a `BlockResult` is returned with **code** SUCCESS and **block** set (block has header, items, and proof).

7. **Given** a block number that does not exist, **when** `BlockQuery().setBlockNumber(n).execute(client)` is called, **then** a `BlockResult` is returned with **code** NOT_FOUND and **block** null; the SDK or caller can use the code to avoid retrying.

8. **Given** a block number outside the node's available range, **when** `BlockQuery().setBlockNumber(n).execute(client)` is called, **then** a `BlockResult` is returned with **code** NOT_AVAILABLE and **block** null; the SDK or caller can use the code to configure retry (e.g. try another node).

9. **Given** a `BlockQuery`, **when** `setRetrieveLatest(true).execute(client)` is called, **then** a `BlockResult` with **code** SUCCESS and the latest available **block** is returned.

### BlockStreamQuery

10. **Given** a valid start block number, **when** `BlockStreamQuery().setStartBlockNumber(n).subscribe(client, onNext)` is called, **then** a **SubscriptionHandle** is returned and the **onNext** callback is invoked for each block starting from block n.

11. **Given** an active block stream subscription, **when** blocks are delivered by the server, **then** the **onNext** callback is invoked with blocks in ascending order by block number.

12. **Given** a block stream with start and end block numbers, **when** the end block is reached, **then** the stream ends and the completion handler (if set) is invoked.

13. **Given** a block stream subscription with no end block, **when** new blocks are produced, **then** they are delivered via the **onNext** callback until **unsubscribe()** is called on the handle.

14. **Given** an invalid start block number (greater than available), **when** `BlockStreamQuery().setStartBlockNumber(n).subscribe(client, onNext)` is called, **then** an error with `INVALID_START_BLOCK_NUMBER` is reported (e.g. via error handler or by failing the subscribe call).

15. **Given** an end block less than start block, **when** `BlockStreamQuery().setStartBlockNumber(10).setEndBlockNumber(5).subscribe(client, onNext)` is called, **then** an error with `INVALID_END_BLOCK_NUMBER` is reported.

16. **Given** a start and end block number, **when** `BlockStreamQuery().setStartBlockNumber(n).setEndBlockNumber(m).subscribe(client, onNext)` is called, **then** the **onNext** callback is invoked for each block in the range until the end block is delivered, after which the completion handler (if set) is invoked.

17. **Given** an active block stream subscription, **when** **unsubscribe()** is called on the returned handle, **then** the stream is cancelled and no further **onNext** callbacks are invoked.

### Error Handling and Resilience

18. **Given** a `Client` experiencing transient Block Node connection errors, **when** any Block Node query is executed, **then** the SDK retries with exponential backoff before failing.

19. **Given** a `Client` with multiple Block Node addresses configured, **when** one Block Node becomes unhealthy, **then** queries are routed to healthy Block Nodes.

### TCK

The tests defined above should be implemented in the [TCK repository](https://github.com/hiero-ledger/hiero-sdk-tck). Issues should be created to track:
- Client Block Node configuration tests
- Block access and retrieval tests
- Block stream subscription tests
- Error handling and resilience tests

---

## SDK Example

### Subscribing to Real-Time Block Stream

This example demonstrates how to connect to a Block Node and subscribe to a live block stream, following patterns established by `TopicMessageQuery`:

```
// 1. Create a client and configure the Block Node network
client = Client.forTestnet()
client.setOperator(operatorId, operatorKey)
client.setBlockNodeNetwork(["block-node-1.example.com:8080", "block-node-2.example.com:8080"])

// 2. Query Block Node status to understand available data
status = ServerStatusQuery().execute(client)
print("Available blocks: " + status.firstAvailableBlock + " to " + status.lastAvailableBlock)

// 3. Subscribe to the block stream starting from the latest available block
handle = BlockStreamQuery()
    .setStartBlockNumber(status.lastAvailableBlock)
    .setErrorHandler(err => print("Stream error: " + err))
    .setCompletionHandler(() => print("Stream completed"))
    .subscribe(client, block => {
        print("Block " + block.items.size + " items")
    })

// 4. Later, stop the subscription
handle.unsubscribe()
```

### Retrieving a Specific Block

This example shows how to retrieve a specific block by number and examine its contents:

```
// 1. Create a client with Block Node access (no operator needed for read-only queries)
client = Client.forTestnet()
client.setBlockNodeNetwork(["block-node-1.example.com:8080"])

// 2. Get a specific block by number
result = BlockQuery()
    .setBlockNumber(42)
    .execute(client)

if result.code == BlockAccessResponseCode.SUCCESS {
    block = result.block
    print("Block items: " + block.items.size)
} else if result.code == BlockAccessResponseCode.NOT_FOUND {
    print("Block does not exist")
} else if result.code == BlockAccessResponseCode.NOT_AVAILABLE {
    print("Block not available on this node, try another")
}

// 3. Get the latest available block
latestResult = BlockQuery()
    .setRetrieveLatest(true)
    .execute(client)
```

### Subscribing to a Historical Block Range

This example shows how to subscribe to a bounded range of historical blocks:

```
client = Client.forTestnet()
client.setBlockNodeNetwork(["block-node-1.example.com:8080"])

// Subscribe to blocks 100 through 200; stream ends after block 200
handle = BlockStreamQuery()
    .setStartBlockNumber(100)
    .setEndBlockNumber(200)
    .setCompletionHandler(() => print("Finished processing block range"))
    .subscribe(client, block => {
        print("Processing block")
    })
```

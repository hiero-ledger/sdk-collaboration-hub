# HIP-1137: Block Node Discoverability via On-Chain Registry

## Summary

[HIP-1137](https://github.com/hiero-ledger/hiero-improvement-proposals/blob/main/HIP/hip-1137.md) introduces a registered node registry to the Hiero ledger, enabling block node operators (and other registered node types such as mirror nodes and RPC relays) to publish their nodes on-chain so that clients can discover them. The HIP adds three new transactions to the `AddressBookService`:

- **RegisteredNodeCreate** -- creates a new registered node entry in network state.
- **RegisteredNodeUpdate** -- modifies an existing registered node entry.
- **RegisteredNodeDelete** -- removes a registered node entry from network state.

Each registered node is identified by a unique `uint64` ID assigned by the network on creation. This ID is returned in the `TransactionReceipt` after a successful create. Registered node IDs are never reused and do not overlap with consensus node IDs.

The HIP also extends the existing consensus node address book (`Node`, `NodeCreateTransactionBody`, `NodeUpdateTransactionBody`) with an `associated_registered_node` field, allowing consensus node operators to declare which registered nodes they also operate.

All changes are net-new functionality with no backwards compatibility impact.

**Date Submitted:** 2026-02-23

## New APIs

### BlockNodeApi

An enumeration of well-known block node endpoint APIs.

```
enum BlockNodeApi {
    OTHER
    STATUS
    PUBLISH
    SUBSCRIBE_STREAM
    STATE_PROOF
}
```

### RegisteredServiceEndpoint

A service endpoint published by a registered node. Each endpoint declares an address (IP or FQDN), port, TLS requirement, and the type of node service it provides.

The endpoint hierarchy uses inheritance rather than composition: `RegisteredServiceEndpoint` is an abstract base type with three concrete subtypes - one per node service kind. This design lets the type system enforce that each endpoint is exactly one kind (block node, mirror node, or RPC relay) without requiring a runtime `@@oneOf` check or marker-object fields.

`MirrorNodeServiceEndpoint` and `RpcRelayServiceEndpoint` are intentionally defined as empty subtypes. The protobuf specification defines these as separate messages so that type-specific fields can be added in future HIPs without restructuring the endpoint hierarchy. Defining them now means each subtype can independently gain fields without introducing breaking API changes.

```
@@oneOf(ipAddress, domainName)
abstraction RegisteredServiceEndpoint {
    @@nullable ipAddress: bytes
    @@nullable domainName: string
    @@default(0) port: uint32
    @@default(false) requiresTls: bool
}
```

#### BlockNodeServiceEndpoint

A registered service endpoint for a block node. Extends the base endpoint with the specific block node API that the endpoint exposes.

```
@@finalType
BlockNodeServiceEndpoint extends RegisteredServiceEndpoint {
    endpointApi: BlockNodeApi
}
```

#### MirrorNodeServiceEndpoint

A registered service endpoint for a mirror node. Currently carries no additional fields beyond the base endpoint. Defined as a distinct subtype so that mirror-node-specific fields can be added in future HIPs without breaking changes.

```
@@finalType
MirrorNodeServiceEndpoint extends RegisteredServiceEndpoint {
}
```

#### RpcRelayServiceEndpoint

A registered service endpoint for an RPC relay. Currently carries no additional fields beyond the base endpoint. Defined as a distinct subtype so that RPC-relay-specific fields can be added in future HIPs without breaking changes.

```
@@finalType
RpcRelayServiceEndpoint extends RegisteredServiceEndpoint {
}
```

### RegisteredNodeCreateTransaction

Creates a new registered node in the network address book. The `adminKey` must sign this transaction. Upon success, the network assigns a unique `registeredNodeId` which is returned in the `TransactionReceipt`.

```
RegisteredNodeCreateTransaction {
    @@nullable adminKey: Key
    @@nullable description: string
    @@nullable nodeAccountId: AccountId
    serviceEndpoints: list<RegisteredServiceEndpoint>

    RegisteredNodeCreateTransaction addServiceEndpoint(serviceEndpoint: RegisteredServiceEndpoint)
}
```

### RegisteredNodeDeleteTransaction

Removes a registered node from the network address book. Must be signed by the registered node's `adminKey` or authorized by the network governance structure.

```
RegisteredNodeDeleteTransaction {
    @@default(0) registeredNodeId: uint64
}
```

### RegisteredNodeUpdateTransaction

Updates an existing registered node in the network address book. Must be signed by the registered node's current `adminKey`. If `adminKey` is being changed, both the old and new key must sign.

When `serviceEndpoints` is set to a non-empty list, it replaces the existing endpoint list entirely. When left empty (the default), the existing endpoints are unchanged.

When `description` is set, it replaces the existing description. When left null, the existing description is unchanged.

```
RegisteredNodeUpdateTransaction {
    @@default(0) registeredNodeId: uint64
    @@nullable adminKey: Key
    @@nullable description: string
    @@nullable nodeAccountId: AccountId
    serviceEndpoints: list<RegisteredServiceEndpoint>

    RegisteredNodeUpdateTransaction addServiceEndpoint(serviceEndpoint: RegisteredServiceEndpoint)
}
```

---

## Updated APIs

### TransactionReceipt

A new field is added to hold the registered node ID assigned after a successful `RegisteredNodeCreateTransaction`.

```
TransactionReceipt {
    @@immutable @@nullable registeredNodeId: uint64
}
```

### NodeCreateTransaction

A new field allows a consensus node operator to declare registered nodes that it also operates.

```
NodeCreateTransaction {
    associatedRegisteredNodes: list<uint64>

    NodeCreateTransaction addAssociatedRegisteredNode(registeredNodeId: uint64)
}
```

### NodeUpdateTransaction

Same field as above, applied to updating an existing consensus node. When set to a non-empty list, it replaces the existing associated registered nodes. When left empty (the default), the existing associations are unchanged.

```
NodeUpdateTransaction {
    associatedRegisteredNodes: list<uint64>

    NodeUpdateTransaction addAssociatedRegisteredNode(registeredNodeId: uint64)
}
```

---

## Internal Changes

### Schedulability

All three registered node transactions (`RegisteredNodeCreateTransaction`, `RegisteredNodeUpdateTransaction`, `RegisteredNodeDeleteTransaction`) are schedulable via `ScheduleCreateTransaction`. The HIP adds each to `SchedulableTransactionBody`. Each SDK already has an internal mechanism for making transactions schedulable - the concrete implementation will be SDK-specific.

### Response Codes

HIP-1137 does not define any new response codes. If response codes specific to registered node transactions are introduced during consensus node implementation, this document should be updated to document them and evaluate any transaction retry implications for the SDKs.

## Test Plan

1. Given a valid admin key and a single block node service endpoint, when a `RegisteredNodeCreateTransaction` is executed, then the transaction succeeds and the `TransactionReceipt` contains a non-zero `registeredNodeId`.

2. Given a valid admin key and a single mirror node service endpoint, when a `RegisteredNodeCreateTransaction` is executed, then the transaction succeeds and the registered node is created with a mirror node endpoint.

3. Given a valid admin key and a single RPC relay service endpoint, when a `RegisteredNodeCreateTransaction` is executed, then the transaction succeeds and the registered node is created with an RPC relay endpoint.

4. Given a valid admin key and multiple service endpoints of mixed types (block node, mirror node, RPC relay), when a `RegisteredNodeCreateTransaction` is executed, then the transaction succeeds and all endpoints are stored.

5. Given a valid admin key, a description, and service endpoints, when a `RegisteredNodeCreateTransaction` is executed, then the transaction succeeds and the registered node is created with the provided description.

6. Given a `RegisteredNodeCreateTransaction` with no admin key set, when the transaction is executed, then the transaction fails.

7. Given a `RegisteredNodeCreateTransaction` with an empty service endpoints list, when the transaction is executed, then the transaction fails.

8. Given an existing registered node, when a `RegisteredNodeUpdateTransaction` updates the description, then the description is replaced and the update succeeds.

9. Given an existing registered node, when a `RegisteredNodeUpdateTransaction` replaces the service endpoints with a new list, then the old endpoints are replaced and the update succeeds.

10. Given an existing registered node, when a `RegisteredNodeUpdateTransaction` sets a new admin key and the transaction is signed by both the old and new admin keys, then the admin key is updated successfully.

11. Given an existing registered node, when a `RegisteredNodeUpdateTransaction` sets a new admin key but only the old admin key signs, then the transaction fails.

12. Given a `RegisteredNodeUpdateTransaction` targeting a non-existent `registeredNodeId`, when the transaction is executed, then the transaction fails.

13. Given an existing registered node, when a `RegisteredNodeDeleteTransaction` is executed and signed by the admin key, then the registered node is removed from the address book.

14. Given a registered node that has already been deleted, when a `RegisteredNodeDeleteTransaction` is executed for the same `registeredNodeId`, then the transaction fails.

15. Given a `RegisteredNodeDeleteTransaction` targeting a non-existent `registeredNodeId`, when the transaction is executed, then the transaction fails.

16. Given an existing registered node, when a `NodeCreateTransaction` is executed with the registered node's ID in `associatedRegisteredNodes`, then the consensus node is created with the association.

17. Given an existing consensus node and an existing registered node, when a `NodeUpdateTransaction` sets `associatedRegisteredNodes` to include the registered node's ID, then the consensus node is updated with the association.

18. Given an existing registered node created with an IP address endpoint, when a `RegisteredNodeUpdateTransaction` replaces it with a domain name endpoint, then the update succeeds and the endpoint uses the new domain name.

### TCK

The tests defined above should also be defined in the [TCK repository](https://github.com/hiero-ledger/hiero-sdk-tck). Issues should be created in the TCK repository based on this content to document all end-to-end tests and link them as reference in this design doc.

## SDK Example

### Example: Registered Node Lifecycle

This example demonstrates the full lifecycle of a registered node as described in the HIP user stories.

1. Generate a new key pair to serve as the registered node's `adminKey`.
2. Create a `BlockNodeServiceEndpoint` with an IP address, port, TLS enabled, and `endpointApi` set to `BlockNodeApi.SUBSCRIBE_STREAM`.
3. Build a `RegisteredNodeCreateTransaction` with the admin key, a description (e.g., "My Block Node"), and the service endpoint created above.
4. Sign the transaction with the admin key and execute it.
5. Retrieve the `TransactionReceipt` and read the `registeredNodeId` assigned by the network.
6. Verify the `registeredNodeId` is present and non-zero.
7. Create a second `BlockNodeServiceEndpoint` with a domain name, port, TLS enabled, and `endpointApi` set to `BlockNodeApi.STATUS`.
8. Build a `RegisteredNodeUpdateTransaction` targeting the `registeredNodeId` from step 5, setting a new description (e.g., "My Updated Block Node") and adding both the original and new service endpoints.
9. Sign with the admin key and execute.
10. Verify the update succeeded by checking the transaction receipt status.
11. Build a `NodeUpdateTransaction` for an existing consensus node and add the `registeredNodeId` to `associatedRegisteredNodes`.
12. Sign with the consensus node's admin key and execute.
13. Verify the consensus node update succeeded.
14. Build a `RegisteredNodeDeleteTransaction` targeting the `registeredNodeId`.
15. Sign with the registered node's admin key and execute.
16. Verify the deletion succeeded by checking the transaction receipt status.
